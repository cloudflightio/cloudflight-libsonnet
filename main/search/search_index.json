{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the documentation of the Cloudflight jsonnet library.</p> <p>This library contains utilities and premade modules to ease working with Kubernets and OpenShift.</p> <p>To get started, take a look at the guides or the module documentation.</p> <p>If you know your way around jsonnet already, why not take a look at our complete library?</p> <p>If you want support for your editor you should use one of the plugins listed on the tools page. We recommend plugins based on the jsonnet-language server.</p> <p>Info</p> <p><code>cloudflight-libsonnet</code> is inteded to be used with Tanka. Other tools might work, however we do not test for them. If you're using <code>kubecfg</code>, take a look at our migration guide.</p>"},{"location":"guides/","title":"Index","text":"<p>This section contains guides for various usecases concerning our jsonnet library.</p> <p>If you just want to get going, take a look at the quick start.</p>"},{"location":"guides/#external-resources","title":"External Resources","text":"<ul> <li>Jsonnnet Tutorial: https://jsonnet.org/learning/tutorial.html</li> <li>Tanka Tutorial: https://tanka.dev/tutorial/overview</li> <li>k8s-libsonnet: https://jsonnet-libs.github.io/k8s-libsonnet/</li> </ul>"},{"location":"guides/quickstart/","title":"Quick start","text":""},{"location":"guides/quickstart/#setting-up","title":"Setting up","text":"<p>To start using this library, first initialize the working directory using <code>tk init</code>.</p> <p>This will create a directory structure similar to this:</p> <pre><code>.\n\u251c\u2500\u2500 environments\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 default\n\u251c\u2500\u2500 jsonnetfile.json\n\u251c\u2500\u2500 jsonnetfile.lock.json\n\u251c\u2500\u2500 lib\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 k.libsonnet\n\u2514\u2500\u2500 vendor\n    \u251c\u2500\u2500 1.23 -&gt; github.com/jsonnet-libs/k8s-libsonnet/1.23\n    \u251c\u2500\u2500 github.com\n    \u2514\u2500\u2500 ksonnet-util -&gt; github.com/grafana/jsonnet-libs/ksonnet-util\n</code></pre> <p>Next, we need to install the <code>cloudflight-libsonnet</code> library using <code>jb</code>:</p> <pre><code>jb install github.com/cloudflightio/cloudflight-libsonnet@main\n</code></pre> <p>The last step is to adapt the predefined <code>k.libsonnet</code>. When initializing, Tanka simply imports the <code>k8s-libsonnet</code> library here. Since some of our customizations depend on other libraries which have to be imported at this point (such as <code>openshift-libsonnet</code> or <code>prometheus-libsonnet</code>), you replace the contents of <code>k.libsonnet</code> with the following:</p> <pre><code>import 'github.com/cloudflightio/cloudflight-libsonnet/k.libsonnet'\n</code></pre>"},{"location":"guides/quickstart/#using-the-library","title":"Using the library","text":"<p>To use the components provided by this library (or other Kubernetes components), import our <code>prelude.libsonnet</code>.</p> <p>Let's use the library to deploy a simple java based application, backed by an MariaDB instance.</p>"},{"location":"guides/quickstart/#creating-the-application","title":"Creating the application","text":"<p>Applications should be defined in the <code>lib</code> folder. To configure a java application, we create a file called <code>lib/test-java.libsonnet</code> with the contents below.</p> <pre><code>local k = (import 'cloudflight-libsonnet/prelude.libsonnet');\n{\n_config+:: {\nmyApplication: {\nname: 'my-application',\nimage: error '$._config.myApplication.image must be defined',\n},\n},\nmyApplication: {\ndeployment: k.util.java.deployment.new(\nname=$._config.myApplication.name,\nimage=$._config.myApplication.image,\ncontainerMixin=k.core.v1.container.livenessProbe.withInitialDelaySeconds(60),\n),\nservice: k.util.serviceFor(self.deployment),\nroute: k.util.routeFor(self.service, 'hello.example.com'),\n},\n}\n</code></pre> <p>Now we can import this into our environment file <code>environments/default/main.jsonnet</code></p> <pre><code>(import 'test-java.libsonnet')\n+ {\n_config+: {\nmyApplication+: {\nimage: 'helloworld:latest',\n},\n},\n}\n</code></pre> <p>Provided your <code>.kube/config</code> and <code>environments/default/spec.json</code> are set up correctly, you can deploy this by running <code>tk apply environments/default</code>.</p>"},{"location":"guides/quickstart/#adding-the-database","title":"Adding the database","text":"<p>Most applications want to store data somewhere so let's add a database next. First, we import the database of choice in the <code>main.jsonnet</code> file.</p> <pre><code>(import 'cloudflight-libsonnet/databases/mariadb.libsonnet')\n+ (import 'test-java.libsonnet')\n+ {\n_config+: {\nmariadb+: {\nuser: 'application-user',\npassword: 'hunter2',\ndatabase: 'my-application',\n},\nmyApplication+: {\nimage: 'helloworld:latest',\n},\n},\n}\n</code></pre> <p>To connect our application to the database, we need to configure the deployment on a lower level. This is because of the fact, that the plain <code>util.java.deployment</code> does not make any assumptions about databases.</p> <p>As documented in the java module, we build the deployment ourselves, but mix in some environment variables.</p> <pre><code>local k = (import 'cloudflight-libsonnet/prelude.libsonnet');\n{\n_config+:: {\nmyApplication: {\nname: 'my-application',\nimage: error '$._config.myApplication.image must be defined',\ndbUser: error '$._config.myApplication.dbUser must be defined',\ndbPasswordRef: error '$._config.myApplication.dbPasswordRef must be a valid secretSecretKeyRef',\ndbUrl: error '$._config.myApplication.dbUrl must be defined',\n},\n},\nmyApplication: {\ndeployment: k.apps.v1.deployment.new(\nname=$._config.myApplication.name,\nreplicas=1,\ncontainers=[\nk.util.java.container.new($._config.myApplication.name, $._config.myApplication.image)\n+ k.core.v1.container.withEnvMixin([\n{\nname: 'SPRING_DATASOURCE_PASSWORD',\nvalueFrom: { secretKeyRef: $._config.myApplication.dbPasswordRef },\n},\n{\nname: 'SPRING_DATASOURCE_USERNAME',\nvalue: $._config.myApplication.dbUser,\n},\n{\nname: 'SPRING_DATASOURCE_URL',\nvalue: $._config.myApplication.dbUrl,\n},\n]),\n]\n),\nservice: k.util.serviceFor(self.deployment),\nroute: k.util.routeFor(self.service, 'hello.example.com'),\n},\n}\n</code></pre> <p>In the last step, we fill the new config parameters with values.</p> <pre><code>(import 'cloudflight-libsonnet/databases/mariadb.libsonnet')\n+ (import 'test-java.libsonnet')\n+ {\n_config+: {\nmariadb+: {\nuser: 'application-user',\npassword: 'hunter2',\ndatabase: 'my-application',\n},\nmyApplication+: {\nimage: 'helloworld:latest',\ndbUser: $._config.mariadb.user,\ndbPasswordRef: $.mariadb.passwordSecretKeyRef,\ndbUrl: 'jdbc:mysql://' + $.mariadb.service.metadata.name + '/' + $._config.mariadb.database,\n},\n},\nmariadb2: (import 'cloudflight-libsonnet/databases/mariadb.libsonnet') + {\n_config+: {\nmariadb+: {\nname: 'foo',\nuser: 'foo-user',\npassword: 'foo-user',\n},\n},\n},\n}\n</code></pre> <p>And we're done!</p> <p>To recap: we have configured an application, added a database and connected it to our application. The way we connected the applications is transparent, and we could (as long as the application supports it) change the database entirely in our <code>main.jsonnet</code>. This way, we can use different database setups across environment, while keeping the application configuration the same.</p> <p>For more information, check out the documentation of the java utilities and the MariaDB module.</p>"},{"location":"guides/tanka_migration/","title":"Migrating to Tanka","text":"<p>At Cloudflight we were previously using <code>kubecfg</code> to deploy our applications. As of <code>2022-02-21</code>, tanka is our recommended tool for Kubernetes configurations. Reasoning for this can be found in ADR-0077.</p> <p>If you're still using <code>kubecfg</code> you're in Luck! The migration to Tanka is very simple and can be done in under five minutes.</p> <p>Tip</p> <p>TL;DR:</p> <ul> <li>Move stage files to environments/$NAME/main.jsonnet</li> <li>Create environments/$NAME/spec.json</li> <li>Fix Imports</li> </ul>"},{"location":"guides/tanka_migration/#verifying-your-current-setup","title":"Verifying your current setup","text":"<p>Before we can start to migrate to the new setup, we should be confident in the old one to avoid issues further down the line.</p> <p>As a requirement, you should be able to view your configuration in the yaml format by running</p> <pre><code>kubecfg show $YOUR_STAGE_FILE\n</code></pre>"},{"location":"guides/tanka_migration/#restructuring","title":"Restructuring","text":"<p>The main change required for a smooth workflow in Tanka, is a small restructuring of the directory. Our old layout prescribes a flat structure with everything in the root directory. Tanka on the other hand expects a folder per environment. To perform this step, you need to go from this:</p> <pre><code>.\n\u251c\u2500\u2500 jsonnetfile.json\n\u251c\u2500\u2500 production.jsonnet\n\u251c\u2500\u2500 resources\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 application.jsonnet\n\u2514\u2500\u2500 staging.jsonnet\n</code></pre> <p>to</p> <pre><code>.\n\u251c\u2500\u2500 jsonnetfile.json\n\u251c\u2500\u2500 environments\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 production\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 main.jsonnet # (1)\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 staging\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 main.jsonnet # (2)\n\u2514\u2500\u2500 lib\n    \u2514\u2500\u2500 application.libsonnet\n</code></pre> <ol> <li>The old <code>production.jsonnet</code></li> <li>The old <code>staging.jsonnet</code></li> </ol>"},{"location":"guides/tanka_migration/#configuring","title":"Configuring","text":"<p>Instead of relying on the current Kubernetes context, Tanka needs explicit information on the API Server as well as the namespace.</p> <p>This information is saved in the <code>spec.json</code> file, contained in the respective environment. The complete layout can be found in the Tanka documentation</p> <p>The syntax is as follows:</p> <pre><code>{\n\"apiVersion\": \"tanka.dev/v1alpha1\",\n\"kind\": \"Environment\",\n\"metadata\": {\n\"name\": \"environments/staging\"\n},\n\"spec\": {\n\"apiServer\": \"openshift-dev.internal.cloudflight.io:6443\", // (1)\n\"namespace\": \"762-example-staging\", // (2)\n\"resourceDefaults\": {},\n\"expectVersions\": {},\n\"injectLabels\": true\n}\n}\n</code></pre> <ol> <li>API server URL. Excluding theh protocol, including the port</li> <li>Namespace of your project. Will be injected to all resources</li> </ol>"},{"location":"guides/tanka_migration/#fixing-imports","title":"Fixing Imports","text":"<p>Now that you moved around the files, you will also need to fix the imports contained within them. For convenience, Tanka automatically includes the <code>lib</code> and <code>vendor</code> directory in the jsonnet path. So instead of having to write <code>../../lib/application.libsonnet</code> you can simply import <code>application.libsonnet</code>.</p>"},{"location":"guides/tanka_migration/#verifying-the-new-configuration","title":"Verifying the new configuration","text":"<p>After fixing the imports, you can show the new configuration with the following command:</p> <pre><code>tk show environments/staging\n</code></pre>"},{"location":"guides/tanka_migration/#teamcity","title":"TeamCity","text":"<p>Tanka integration from TeamCity is supported from version <code>3.0.0</code> of the cloudflight-teamcity-dsl onwards.</p> <p>Example:</p> <pre><code>subCloudflightProject {\nname = \"Deployment\"\ntankaApply {\nopenShiftConfig {\nserviceAccountToken = \"credentialsJSON:...\"\n}\ncontextDir = \".openshift\" // (1)\n}\n}\n</code></pre> <ol> <li>Default: <code>deployment</code> as is the case with our new configuration skeleton</li> </ol>"},{"location":"library/","title":"cloudflight-libsonnet","text":"<p>This library contains various utility modules for use with the jsonnet configuration language To get started, import the provided prelude which will composit the library for you.</p> <pre><code>local k = import ('cloudflight-libsonnet/prelude.libsonnet');\n</code></pre> <p>The prelude depends on a file called <code>k.libsonnet</code> being available for import. Either place it in your lib or environment folder. Using the environment folder allows for library level configuration options to be applied on an environment level.</p> <p>This works, because import paths are ranked as highlighted in the Tanka documentation.</p> <p>A pre-populated <code>k.libsonnet</code> is available in this library so a minimal <code>k.libsonnet</code> would look like this:</p> <pre><code>(import 'cloudflight-libsonnet/k.libsonnet')\n</code></pre> <p>This includes k8s-libsonnet, openshift-libsonnet as well as prometheus-libsonnet</p> <p>For more information on customization options in <code>k.libsonnet</code>, take a look at the labeling extension.</p> <ul> <li>core</li> <li>extensions</li> <li>labeling</li> <li>networking</li> <li>route</li> <li>util</li> </ul>"},{"location":"library/core/","title":"core","text":"<p>Contains extensions related to core kubernetes components</p>"},{"location":"library/core/#index","title":"Index","text":"<ul> <li><code>obj v1</code></li> <li><code>obj v1.container</code><ul> <li><code>fn new(name, image, unprivileged='true')</code></li> </ul> </li> </ul>"},{"location":"library/core/#fields","title":"Fields","text":""},{"location":"library/core/#obj-v1","title":"obj v1","text":""},{"location":"library/core/#obj-v1container","title":"obj v1.container","text":""},{"location":"library/core/#fn-v1containernew","title":"fn v1.container.new","text":"<pre><code>new(name, image, unprivileged='true')\n</code></pre> <p>new returns a new container of given name and image. By default it injects an openshift 4.11 compatible securityContext</p>"},{"location":"library/extensions/","title":"extensions","text":"<p>Extensions available to the standard library</p>"},{"location":"library/labeling/","title":"labeling","text":"<p>This extension allows you to label core kubernetes resources with useful labels.</p>"},{"location":"library/labeling/#usage","title":"Usage","text":"<p>To use this labeling function, edit your <code>k.libsonnet</code> to look something like this</p> <pre><code>(import 'cloudflight-libsonnet/k.libsonnet')\n+ {\n_config+:: {\nproject: 'some-project-name'\n}\n}\n</code></pre> <p>Afterwards, all resources created (provided they use <code>cloudflight-libsonnet/prelude.libsonnet</code>), will have the <code>cloudflight.io/project=some-project-name</code> label attached</p> <p>If you need to set this on a per-environment basis, move the <code>k.libsonnet</code> file to your environment folder as described in the Tanka documentation.</p>"},{"location":"library/networking/","title":"networking","text":"<p>Contains extensions related to cert-manager</p>"},{"location":"library/networking/#index","title":"Index","text":"<ul> <li><code>obj v1</code></li> <li><code>obj v1.ingress</code><ul> <li><code>fn withCertMixin(issuer, clusterwide)</code></li> </ul> </li> </ul>"},{"location":"library/networking/#fields","title":"Fields","text":""},{"location":"library/networking/#obj-v1","title":"obj v1","text":""},{"location":"library/networking/#obj-v1ingress","title":"obj v1.ingress","text":""},{"location":"library/networking/#fn-v1ingresswithcertmixin","title":"fn v1.ingress.withCertMixin","text":"<pre><code>withCertMixin(issuer, clusterwide)\n</code></pre> <p>withCertMixin instructs cert-manager to add an certificate to the ingress-resource.</p>"},{"location":"library/route/","title":"route","text":"<p>Contains extensions to the default route functions provided by openshift-libsonnet</p>"},{"location":"library/route/#index","title":"Index","text":"<ul> <li><code>obj v1</code></li> <li><code>obj v1.route</code><ul> <li><code>fn new(name, host, path)</code></li> </ul> </li> </ul>"},{"location":"library/route/#fields","title":"Fields","text":""},{"location":"library/route/#obj-v1","title":"obj v1","text":""},{"location":"library/route/#obj-v1route","title":"obj v1.route","text":""},{"location":"library/route/#fn-v1routenew","title":"fn v1.route.new","text":"<pre><code>new(name, host, path)\n</code></pre> <p>builds a route with a predefined host and TLS Edge termination</p>"},{"location":"library/util/","title":"util","text":"<p>The util package contains ease of use functions to simplify working with kubernetes and jsonnet</p>"},{"location":"library/util/#index","title":"Index","text":"<ul> <li><code>fn ingressFor(service, host='', path='/', port='service.spec.ports[0].port')</code></li> <li><code>fn routeFor(service, host='', path='/', port='service.spec.ports[0].port')</code></li> <li><code>fn serviceFor(deployment, ignored_labels, nameFormat='%(port)s')</code></li> <li><code>fn weightedRouteFor(name, host='', port='', services, path='/')</code></li> <li><code>obj certmanager</code></li> <li><code>obj certmanager.issuer</code><ul> <li><code>fn new(emain, ingressClassName='nginx', production=true, clusterwide=true, name='letsencrypt-production || letsencrypt-staging')</code></li> </ul> </li> <li><code>obj java</code></li> <li><code>obj java.container</code><ul> <li><code>fn new(name, image, port=8080, actuatorPort='port+8080', env={})</code></li> </ul> </li> <li><code>obj java.deployment</code><ul> <li><code>fn new(name, image, replicas=1, env={}, containerMixin={}, runtime='spring-boot', component='backend')</code></li> </ul> </li> <li><code>obj java.livenessProbe</code><ul> <li><code>fn new(port=8080, initialDelaySeconds=30)</code></li> </ul> </li> <li><code>obj java.readinessProbe</code><ul> <li><code>fn new(port=18080, path='/actuator/health')</code></li> </ul> </li> <li><code>obj openshiftOAuth</code></li> <li><code>obj openshiftOAuth.container</code><ul> <li><code>fn new(upstream, serviceAccount)</code></li> </ul> </li> <li><code>obj openshiftOAuth.deployment</code><ul> <li><code>fn withProxy(upstream, serviceAccount)</code></li> </ul> </li> <li><code>obj openshiftOAuth.serviceAccount</code><ul> <li><code>fn new(name, route)</code></li> </ul> </li> </ul>"},{"location":"library/util/#fields","title":"Fields","text":""},{"location":"library/util/#fn-ingressfor","title":"fn ingressFor","text":"<pre><code>ingressFor(service, host='', path='/', port='service.spec.ports[0].port')\n</code></pre> <p>ingressFor constructs a ingress object, compatible with the automatic translation to openshift routes. It expects a value for the hostname and defaults to '/' for the path.</p>"},{"location":"library/util/#fn-routefor","title":"fn routeFor","text":"<pre><code>routeFor(service, host='', path='/', port='service.spec.ports[0].port')\n</code></pre> <p>routeFor constructs a openshift route to the specified service. It expects a value for the hostname and defaults to '/' for the path.</p>"},{"location":"library/util/#fn-servicefor","title":"fn serviceFor","text":"<pre><code>serviceFor(deployment, ignored_labels, nameFormat='%(port)s')\n</code></pre> <p>serviceFor constructs a service for the specified deployment.</p> <p>Selector labels are taken from the pod spec but can be ignored using the <code>ignored_labels</code> parameter.</p> <p>The ports of the service will have the same name as in the container spec to avoid confusion. This can be changed with the <code>nameFormat</code> parameter.</p>"},{"location":"library/util/#fn-weightedroutefor","title":"fn weightedRouteFor","text":"<pre><code>weightedRouteFor(name, host='', port='', services, path='/')\n</code></pre> <p>weightedRouteFor constructs a openshift route to the specified services. It expects a value for the name, hostname, port, services and defaults to '/' for the path. services expects an array consisting of objects with the keys name (name of the service) and weight.</p>"},{"location":"library/util/#obj-certmanager","title":"obj certmanager","text":"<p>certman holds functions related to cert-manager (cert-manager.io)</p>"},{"location":"library/util/#obj-certmanagerissuer","title":"obj certmanager.issuer","text":""},{"location":"library/util/#fn-certmanagerissuernew","title":"fn certmanager.issuer.new","text":"<pre><code>new(emain, ingressClassName='nginx', production=true, clusterwide=true, name='letsencrypt-production || letsencrypt-staging')\n</code></pre> <p>constructs a cert-manager issuer resource for letsencrypt with sensible default.</p>"},{"location":"library/util/#obj-java","title":"obj java","text":"<p>java holds my functions related to java based applications</p>"},{"location":"library/util/#obj-javacontainer","title":"obj java.container","text":""},{"location":"library/util/#fn-javacontainernew","title":"fn java.container.new","text":"<pre><code>new(name, image, port=8080, actuatorPort='port+8080', env={})\n</code></pre> <p>constructs a container with reccomended settings for Java/Spring Boot applications. Includes liveness- and readiness probes, activates the <code>kubernetes</code> spring profile and sets sensible resource defaults.</p>"},{"location":"library/util/#obj-javadeployment","title":"obj java.deployment","text":""},{"location":"library/util/#fn-javadeploymentnew","title":"fn java.deployment.new","text":"<pre><code>new(name, image, replicas=1, env={}, containerMixin={}, runtime='spring-boot', component='backend')\n</code></pre> <p>constructs a deployment using the java container. If you need more control, construct this deployment yourself.</p> <p><code>containerMixin</code> can be used to modify the application container. For example: <pre><code>deployment.new(/*...*/,\n  containerMixin=k.core.v1.container.livenessProbe.withInitialDelaySeconds(60))\n</code></pre> increases the initial delay seconds of the default liveness probe.</p> <p>The <code>runtime</code> and <code>component</code> parameters are used to prefill recommended labels</p>"},{"location":"library/util/#obj-javalivenessprobe","title":"obj java.livenessProbe","text":""},{"location":"library/util/#fn-javalivenessprobenew","title":"fn java.livenessProbe.new","text":"<pre><code>new(port=8080, initialDelaySeconds=30)\n</code></pre> <p>new constructs a fresh liveness probe, checking if the tcp port 8080 is open</p>"},{"location":"library/util/#obj-javareadinessprobe","title":"obj java.readinessProbe","text":""},{"location":"library/util/#fn-javareadinessprobenew","title":"fn java.readinessProbe.new","text":"<pre><code>new(port=18080, path='/actuator/health')\n</code></pre> <p>new constructs a fresh readiness probe, checking if the application is up. The port and path of the actuator endpoint can be changed using the parameters.</p>"},{"location":"library/util/#obj-openshiftoauth","title":"obj openshiftOAuth","text":"<p>openshiftOAuth contains utilities to proxy an application using the OpenShift OAuth Proxy</p>"},{"location":"library/util/#obj-openshiftoauthcontainer","title":"obj openshiftOAuth.container","text":""},{"location":"library/util/#fn-openshiftoauthcontainernew","title":"fn openshiftOAuth.container.new","text":"<pre><code>new(upstream, serviceAccount)\n</code></pre> <p>constructs a container proxying connections to the <code>upstream</code> parameter.</p>"},{"location":"library/util/#obj-openshiftoauthdeployment","title":"obj openshiftOAuth.deployment","text":""},{"location":"library/util/#fn-openshiftoauthdeploymentwithproxy","title":"fn openshiftOAuth.deployment.withProxy","text":"<pre><code>withProxy(upstream, serviceAccount)\n</code></pre> <p>add a proxy sidecar to the container. This also sets the service account used by the pod. The ServiceAccount needs to have the correct redirect reference for the route. See <code>openshiftOAuth.serviceAccount.new</code> for an easy way to create a compliant service account</p>"},{"location":"library/util/#obj-openshiftoauthserviceaccount","title":"obj openshiftOAuth.serviceAccount","text":""},{"location":"library/util/#fn-openshiftoauthserviceaccountnew","title":"fn openshiftOAuth.serviceAccount.new","text":"<pre><code>new(name, route)\n</code></pre> <p>constructs a serviceaccount annotated with a oauth-redirectreference pointing to the route parameter</p>"},{"location":"modules/","title":"What are modules?","text":"<p>Modules are ready-to-use setups of existing applications and services. To use them, import them into your <code>main.libsonnet</code> like so:</p> <pre><code>(import 'cloudflight-libsonnet/databases/mariadb.libsonnet') + {\n_config+: {\nmariadb+: {\nuser: 'foo',\npassword: 'bar',\n}\n}\n}\n</code></pre>"},{"location":"modules/java_application/","title":"Java Applications","text":"<p>Even though not strictly a module, this library contains a lot of utility functions to help you deploy Java applications. This page contains some ways these functions can be used.</p>"},{"location":"modules/java_application/#all-in-one","title":"All-in-one","text":"<p>This example contains the deployment of a simple spring boot based application. It should be located somewhere like <code>lib/my-application.libsonnet</code>.</p> jsonnetyaml <pre><code>local k = (import 'cloudflight-libsonnet/prelude.libsonnet');\n{\n_config+:: {\nmyApplication: {\nname: 'my-application',\nimage: error '$._config.myApplication.image must be defined',\n},\n},\nmyApplication: {\ndeployment: k.util.java.deployment.new(\nname=$._config.myApplication.name,\nimage=$._config.myApplication.image,\ncontainerMixin=k.core.v1.container.livenessProbe.withInitialDelaySeconds(60),\n),\nservice: k.util.serviceFor(self.deployment),\nroute: k.util.routeFor(self.service, 'hello.example.com'),\n},\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\nlabels:\nname: my-application\nname: my-application\nnamespace: test-java\nspec:\nports:\n- name: my-application-http\nport: 8080\ntargetPort: 8080\n- name: my-application-actuator\nport: 9080\ntargetPort: 9080\nselector:\nname: my-application\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: my-application\nnamespace: test-java\nspec:\nminReadySeconds: 10\nreplicas: 1\nrevisionHistoryLimit: 10\nselector:\nmatchLabels:\nname: my-application\ntemplate:\nmetadata:\nlabels:\nname: my-application\nspec:\ncontainers:\n- env:\n- name: SPRING_PROFILES_ACTIVE\nvalue: kubernetes\nimage: helloworld:latest\nimagePullPolicy: IfNotPresent\nlivenessProbe:\nfailureThreshold: 5\ninitialDelaySeconds: 30\nperiodSeconds: 10\nsuccessThreshold: 1\ntcpSocket:\nport: 8080\ntimeoutSeconds: 1\nname: my-application\nports:\n- containerPort: 8080\nname: http\n- containerPort: 9080\nname: actuator\nreadinessProbe:\nfailureThreshold: 5\nhttpGet:\npath: /actuator/health\nport: 18080\ninitialDelaySeconds: 30\nperiodSeconds: 10\nsuccessThreshold: 1\ntimeoutSeconds: 1\nresources:\nlimits:\ncpu: 500m\nmemory: 1Gi\nrequests:\ncpu: 100m\nmemory: 1Gi\n---\napiVersion: route.openshift.io/v1\nkind: Route\nmetadata:\nname: my-application\nnamespace: test-java\nspec:\nhost: hello.example.com\npath: /\nport:\ntargetPort: 8080\ntls:\ninsecureEdgeTerminationPolicy: Redirect\ntermination: Edge\nto:\nkind: Service\nname: my-application\n</code></pre> <p>Switch between the tabs to see the rendered output</p>"},{"location":"modules/java_application/#diy","title":"DIY","text":"<p>If you have the need for further customization, you can pick and choose parts of the library you would like to use.</p> <p>In this example, we want to modify the container so we use the <code>util.java.container.new()</code> to get a base structure and extend it. This way, we still have the defaults set, but are able to customize them to our hearts content.</p> jsonnetyaml <pre><code>local k = (import 'cloudflight-libsonnet/prelude.libsonnet');\n{\n_config+:: {\nmyApplication: {\nname: 'my-application',\nimage: error '$._config.myApplication.image must be defined',\n},\n},\nmyApplication: {\ndeployment: k.apps.v1.deployment.new(\nname=$._config.myApplication.name,\nreplicas=2,\ncontainers=[\nk.util.java.container.new($._config.myApplication.name, $._config.myApplication.image)\n+ k.core.v1.container.withVolumeMounts([\nk.core.v1.volumeMount.new(name='temp', mountPath='/opt/cache'),\n]),\n]\n)\n+ k.apps.v1.deployment.spec.template.spec.withVolumes([\nk.core.v1.volume.fromEmptyDir(name='temp'),\n]),\nservice: k.util.serviceFor(self.deployment),\nroute: k.util.routeFor(self.service, 'hello.example.com'),\n},\n}\n</code></pre> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\nlabels:\nname: my-application\nname: my-application\nnamespace: test-java-diy\nspec:\nports:\n- name: my-application-http\nport: 8080\ntargetPort: 8080\n- name: my-application-actuator\nport: 9080\ntargetPort: 9080\nselector:\nname: my-application\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: my-application\nnamespace: test-java-diy\nspec:\nminReadySeconds: 10\nreplicas: 2\nrevisionHistoryLimit: 10\nselector:\nmatchLabels:\nname: my-application\ntemplate:\nmetadata:\nlabels:\nname: my-application\nspec:\ncontainers:\n- env:\n- name: SPRING_PROFILES_ACTIVE\nvalue: kubernetes\nimage: helloworld:latest\nimagePullPolicy: IfNotPresent\nlivenessProbe:\nfailureThreshold: 5\ninitialDelaySeconds: 30\nperiodSeconds: 10\nsuccessThreshold: 1\ntcpSocket:\nport: 8080\ntimeoutSeconds: 1\nname: my-application\nports:\n- containerPort: 8080\nname: http\n- containerPort: 9080\nname: actuator\nreadinessProbe:\nfailureThreshold: 5\nhttpGet:\npath: /actuator/health\nport: 18080\ninitialDelaySeconds: 30\nperiodSeconds: 10\nsuccessThreshold: 1\ntimeoutSeconds: 1\nresources:\nlimits:\ncpu: 500m\nmemory: 1Gi\nrequests:\ncpu: 100m\nmemory: 1Gi\nvolumeMounts:\n- mountPath: /opt/cache\nname: temp\nvolumes:\n- emptyDir: {}\nname: temp\n---\napiVersion: route.openshift.io/v1\nkind: Route\nmetadata:\nname: my-application\nnamespace: test-java-diy\nspec:\nhost: hello.example.com\npath: /\nport:\ntargetPort: 8080\ntls:\ninsecureEdgeTerminationPolicy: Redirect\ntermination: Edge\nto:\nkind: Service\nname: my-application\n</code></pre>"},{"location":"modules/applications/mailhog/","title":"Mailhog","text":"<p>This module creates an instance of mailhog. Data is stored in memory only so messages will disappear after a pod restart.</p> <p>The following snippet lists all available configuration options alongside their default values:</p> <pre><code>(import 'cloudflight-libsonnet/applications/mailhog.libsonnet')\n+ {\n_config+: {\nmailhog: {\nname: 'mailhog',\nimage: 'docker.io/anatomicjc/mailhog:1.0.1',\nhost: error '$._config.mailhog.host must be defined',\nresources:: {\nlimits: {\ncpu: '20m',\nmemory: '128Mi',\n},\nrequests: {\ncpu: '10m',\nmemory: '64Mi',\n},\n},\n},\n}\n}\n</code></pre>"},{"location":"modules/applications/spring-boot-admin/","title":"Spring Boot Admin","text":"<p>This module creates an instance of spring-boot-admin, preconfigured to discover endpoints via Kubernetes.</p> <p>The following snippets lists all available configuration options alongside their default values:</p> <pre><code>(import 'cloudflight-libsonnet/applications/spring-boot-admin.libsonnet')\n+ {\n_config+: {\nspringBootAdmin: {\nname: 'spring-boot-admin',\nimage: 'ghcr.io/cloudflightio/spring-boot-admin-docker:2.7.3',\nhost: error '$._config.springBootAdmin.host must be defined',\nserviceAccountName: 'default',\nconfig: {\nspring: {\ncloud: {\nkubernetes: {\ndiscovery: {\nenabled: true,\n'service-labels': {\n'[app.openshift.io/runtime]': 'spring-boot',\n},\ncatalogServiceWatchDelay: 300,\n'primary-port-name': 'actuator',\n},\n},\n},\n},\n},\nresources:: {\nlimits: {\ncpu: '500m',\nmemory: '512Mi',\n},\nrequests: {\ncpu: '10m',\nmemory: '512Mi',\n},\n},\n},\n}\n}\n</code></pre>"},{"location":"modules/applications/spring-boot-admin/#integration-and-service-discovery","title":"Integration and Service Discovery","text":"<p>When using our java helpers, spring-boot-admin will automatically discover provided services and their respective actuator endpoints.</p> <p>To customize the discovery, modify <code>$._config.springBootAdmin.config.spring.cloud.kubernetes.discovery</code> to match your labels.</p>"},{"location":"modules/databases/mariadb/","title":"MariaDB Database Module","text":"<p>This module contains a MariaDB instance, located in the <code>mariadb</code> key.</p> <p>The following snippets lists all available configuration options alongside their default values:</p> <pre><code>(import 'cloudflight-libsonnet/databases/mariadb.libsonnet')\n+ {\n_config+: {\nmariadb: {\nname: 'mariadb',\nstorage: '5Gi',\nuser: error 'cfg.user must be defined',\npassword: error 'cfg.password must be defined',\ndatabase: self.user,\nimage: 'registry.redhat.io/rhel9/mariadb-105:1-105',\ndatadirAction: 'upgrade-warn',  // use 'upgrade-auto' to enable auto-upgrade when going to newer MariaDB version\nexporterImage: 'docker.io/prom/mysqld-exporter:v0.14.0',\nexporter_password: std.md5(self.password),\nresources:: {\nlimits: {\ncpu: '500m',\nmemory: '2Gi',\n},\nrequests: {\ncpu: '200m',\nmemory: '1Gi',\n},\n},\n},\n}\n}\n</code></pre>"},{"location":"modules/databases/mariadb/#exposed-values","title":"Exposed values","text":"<p>The following values are exposed, but not exported:</p> Name Contents <code>mariadb.passwordSecretKeyRef</code> A kubernetes <code>secretKeyRef</code>, referencing the user password"},{"location":"modules/databases/mariadb/#starting-multiple-instances","title":"Starting multiple instances","text":"<p>Another way to use this module, is by calling the <code>newMariaDB</code> function. This allows you to create multiple instances without polluting the global scope.</p> <pre><code>{\n_config+:: {\ndbOne: {\nname: 'dbOne',\nuser: 'foo',\npassword: 'bar',\n},\ndbTwo: {\nname: 'dbTwo',\nuser: 'foo',\npassword: 'bar',\n}\n}\ndbOne: (import 'cloudflight-libsonnet/databases/mariadb.libsonnet').newMariaDB($._config.dbOne),\ndbTwo: (import 'cloudflight-libsonnet/databases/mariadb.libsonnet').newMariaDB($._config.dbTwo),\n}\n</code></pre>"},{"location":"modules/databases/mssql/","title":"MSSQL Database Module","text":"<p>This module contains a simple MSSQL instance, located in the <code>mssql</code> key.</p> <p>The following snippets lists all available configuration options alongside their default values:</p> <p>Info</p> <p>You need to set <code>acceptEula</code> to true to accept the MSSQL EULA</p> <pre><code>(import 'cloudflight-libsonnet/databases/mssql.libsonnet')\n+ {\n_config+: {\nmssql: {\nname: 'mssql',\nstorage: '5Gi',\n// The password must be at least 8 characters long and contain characters from three of the following four sets: Uppercase letters, Lowercase letters, Base 10 digits, and Symbols\nrootPassword: error 'cfg.rootPassword must be defined',\nproductId: 'Developer',\nimage: 'mcr.microsoft.com/mssql/rhel/server:2022-latest',\nacceptEula: false,\nresources:: {\nlimits: {\ncpu: '500m',\nmemory: '2Gi',\n},\nrequests: {\ncpu: '200m',\nmemory: '2Gi',\n},\n},\n},\n}\n}\n</code></pre>"},{"location":"modules/databases/mssql/#exposed-values","title":"Exposed values","text":"<p>The following values are exposed, but not exported:</p> Name Contents <code>mssql.passwordSecretKeyRef</code> A kubernetes <code>secretKeyRef</code>, referencing the SA password"},{"location":"modules/databases/redis/","title":"Redis Cache Module","text":"<p>This module contains a Redis Cache, located in the <code>redis</code> key.</p> <p>The following snippets lists all available configuration options alongside their default values:</p> <pre><code>(import 'cloudflight-libsonnet/databases/redis.libsonnet')\n+ {\n_config+: {\nredis: {\nname: 'redis',\nimage: 'registry.redhat.io/rhel8/redis-6:1-62',\nexporterImage: 'docker.io/oliver006/redis_exporter:v1.43.0',\npassword: error 'cfg.password must either be defined or set to null',\nstorage: null,\nresources:: {\nlimits: {\ncpu: '100m',\nmemory: '2Gi',\n},\nrequests: {\ncpu: '50m',\nmemory: '1Gi',\n},\n},\n},\n}\n}\n</code></pre>"},{"location":"modules/databases/redis/#starting-multiple-instances","title":"Starting multiple instances","text":"<p>Another way to use this module, is by calling the <code>newRedis</code> function. This allows you to create multiple instances without polluting the global scope.</p> <pre><code>{\n_config+:: {\ncacheOne: {\nname: 'cacheOne',\npassword: 'foo',\n},\ncacheTwo: {\nname: 'cacheTwo',\npassword: 'bar',\n}\n},\ncacheOne: (import 'cloudflight-libsonnet/databases/redis.libsonnet').newRedis($._config.cacheOne),\ncacheTwo: (import 'cloudflight-libsonnet/databases/redis.libsonnet').newRedis($._config.cacheTwo),\n}\n</code></pre>"},{"location":"modules/databases/redis/#high-availability","title":"High Availability","text":"<p>If required, you can instead import the <code>redis-sentinel</code> module. This creates an additional sentinel deployment which fails over the master and replicas:</p> <pre><code>(import 'cloudflight-libsonnet/databases/redis-sentinel.libsonnet')\n+ {\n_config+: {\nredis: {\nname: 'redis',\nreplicas: 3,\nsentinels: 3,\nimage: 'quay.io/fedora/redis-6:20221012',\nexporterImage: 'docker.io/oliver006/redis_exporter:v1.43.0',\npassword: error 'cfg.password must either be defined or set to null',\ntopologyKey: 'kubernetes.io/hostname',\nstorage: null,\nresources:: {\nlimits: {\ncpu: '100m',\nmemory: '2Gi',\n},\nrequests: {\ncpu: '50m',\nmemory: '1Gi',\n},\n},\n},\n}\n}\n</code></pre>"},{"location":"modules/databases/redis/#exposed-values","title":"Exposed values","text":"<p>When using <code>redis-sentinel</code>, you also have access to the following values. They are exposed, but not exported.</p> Name Contents <code>redis.sentinelNodes</code> Array of sentinel host:port pairs"},{"location":"modules/infrastructure/cert-manager/","title":"Cert-Manager Module","text":"<p>This adds certmanager (see https://cert-manager.io/), located in the <code>certmanager</code> key.</p> <p>It helpes you issuing and managing certificated using custom k8s resources only. </p> <p>The following snippets lists all available configuration options alongside their default values:</p> <pre><code>(import 'cloudflight-libsonnet/infrastructure/cert-manager/cert-manager.libsonnet')\n+ {\n_config+: {\ncertmanager: {\nname: 'cert-manager',\naks: false,\n},\n}\n}\n</code></pre>"},{"location":"modules/infrastructure/cert-manager/#example","title":"Example","text":"<pre><code>(import 'cloudflight-libsonnet/infrastructure/cert-manager/cert-manager.libsonnet')\n+ {\n_config+: {\ncertmanager: {\nname: 'cert-manager',\nnamespace: 'cert-manager',\naks: true,\n},\n},\n}\n</code></pre>"},{"location":"modules/infrastructure/cert-manager/#addons","title":"Addons","text":"<p>There is also a special set of utilities and extensions that can be used to make the setup process easier.</p> <p>This example installs cert-manager, adds a lets-encrypt issuer and a ssl-protected ingress-rule:</p> <pre><code>local k = (import 'k.libsonnet');\nlocal ingress = k.networking.v1.ingress;\n(import 'cloudflight-libsonnet/infrastructure/cert-manager/cert-manager.libsonnet')\n+ {\nissuer: k.util.certmanager.issuer.new('admin@example.com'),\ningress: ingress.new('test.example.com') + ingress.withCertMixin($.issuer),\n}\n</code></pre>"},{"location":"modules/infrastructure/k8s-digester/","title":"k8s-digester Module","text":"<p>This module installs the k8s-digester in your cluster. It currently does not offer any customization options and is functionally equivalent to applying the <code>digester_manifest.yaml</code>.</p> <p>The reason for this module is to have everything you need in one place without relying on manual <code>kubectl apply</code> steps.</p>"},{"location":"modules/infrastructure/nginx-ingress/","title":"Nginx-Ingress Module","text":"<p>This adds nginx-ingress-controller (see https://github.com/kubernetes/ingress-nginx), located in the <code>nginxingress</code> key.</p> <p>This is helpful if no other ingress-controller is deployes (e.g. AKS without API Gateway). </p> <p>The following snippets lists all available configuration options alongside their default values:</p> <pre><code>(import 'cloudflight-libsonnet/infrastructure/nginx-ingress/nginx-ingress.libsonnet')\n+ {\n_config+: {\nnginxingress: {\nname: 'nginx-ingress',\nloadBalancerIP: error 'you need a static loadbalancer (public ip)',\nreplicas: 2,\n},\n}\n}\n</code></pre>"}]}