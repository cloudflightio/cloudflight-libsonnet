{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Welcome to the documentation of the Cloudflight jsonnet library . This library contains utilities and premade modules to ease working with Kubernets and OpenShift. To get started, take a look at the guides or the module documentation . If you know your way around jsonnet already, why not take a look at our complete library ? If you want support for your editor you should use one of the plugins listed on the tools page. We recommend plugins based on the jsonnet-language server . Info cloudflight-libsonnet is inteded to be used with Tanka . Other tools might work, however we do not test for them. If you're using kubecfg , take a look at our migration guide .","title":"Home"},{"location":"#home","text":"Welcome to the documentation of the Cloudflight jsonnet library . This library contains utilities and premade modules to ease working with Kubernets and OpenShift. To get started, take a look at the guides or the module documentation . If you know your way around jsonnet already, why not take a look at our complete library ? If you want support for your editor you should use one of the plugins listed on the tools page. We recommend plugins based on the jsonnet-language server . Info cloudflight-libsonnet is inteded to be used with Tanka . Other tools might work, however we do not test for them. If you're using kubecfg , take a look at our migration guide .","title":"Home"},{"location":"guides/","text":"This section contains guides for various usecases concerning our jsonnet library. If you just want to get going, take a look at the quick start . External Resources Jsonnnet Tutorial: https://jsonnet.org/learning/tutorial.html Tanka Tutorial: https://tanka.dev/tutorial/overview k8s-libsonnet: https://jsonnet-libs.github.io/k8s-libsonnet/","title":"Index"},{"location":"guides/#external-resources","text":"Jsonnnet Tutorial: https://jsonnet.org/learning/tutorial.html Tanka Tutorial: https://tanka.dev/tutorial/overview k8s-libsonnet: https://jsonnet-libs.github.io/k8s-libsonnet/","title":"External Resources"},{"location":"guides/quickstart/","text":"Quick start Setting up To start using this library, first initialize the working directory using tk init . This will create a directory structure similar to this: . \u251c\u2500\u2500 environments \u2502 \u2514\u2500\u2500 default \u251c\u2500\u2500 jsonnetfile.json \u251c\u2500\u2500 jsonnetfile.lock.json \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 k.libsonnet \u2514\u2500\u2500 vendor \u251c\u2500\u2500 1.23 -> github.com/jsonnet-libs/k8s-libsonnet/1.23 \u251c\u2500\u2500 github.com \u2514\u2500\u2500 ksonnet-util -> github.com/grafana/jsonnet-libs/ksonnet-util Next, we need to install the cloudflight-libsonnet library using jb : jb install github.com/cloudflightio/cloudflight-libsonnet@main The last step is to adapt the predefined k.libsonnet . When initializing, Tanka simply imports the k8s-libsonnet library here. Since some of our customizations depend on other libraries which have to be imported at this point (such as openshift-libsonnet or prometheus-libsonnet ), you replace the contents of k.libsonnet with the following: import 'github.com/cloudflightio/cloudflight-libsonnet/k.libsonnet' Using the library To use the components provided by this library (or other Kubernetes components), import our prelude.libsonnet . Let's use the library to deploy a simple java based application, backed by an MariaDB instance. Creating the application Applications should be defined in the lib folder. To configure a java application, we create a file called lib/test-java.libsonnet with the contents below. local k = ( import 'cloudflight-libsonnet/prelude.libsonnet' ); { _config +:: { myApplication : { name : 'my-application' , image : error '$._config.myApplication.image must be defined' , }, }, myApplication : { deployment : k.util.java.deployment.new ( name = $ . _config . myApplication . name , image = $ . _config . myApplication . image ), service : k.util.serviceFor ( self . deployment ), route : k.util.routeFor ( self . service , 'hello.example.com' ), }, } Now we can import this into our environment file environments/default/main.jsonnet ( import 'test-java.libsonnet' ) + { _config +: { myApplication +: { image : 'helloworld:latest' , }, }, } Provided your .kube/config and environments/default/spec.json are set up correctly, you can deploy this by running tk apply environments/default . Adding the database Most applications want to store data somewhere so let's add a database next. First, we import the database of choice in the main.jsonnet file. ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ) + ( import 'test-java.libsonnet' ) + { _config +: { mariadb +: { user : 'application-user' , password : 'hunter2' , database : 'my-application' , }, myApplication +: { image : 'helloworld:latest' , }, }, } To connect our application to the database, we need to configure the deployment on a lower level. This is because of the fact, that the plain util.java.deployment does not make any assumptions about databases. As documented in the java module, we build the deployment ourselves, but mix in some environment variables. local k = ( import 'cloudflight-libsonnet/prelude.libsonnet' ); { _config +:: { myApplication : { name : 'my-application' , image : error '$._config.myApplication.image must be defined' , dbUser : error '$._config.myApplication.dbUser must be defined' , dbPasswordRef : error '$._config.myApplication.dbPasswordRef must be a valid secretSecretKeyRef' , dbUrl : error '$._config.myApplication.dbUrl must be defined' , }, }, myApplication : { deployment : k.apps.v1.deployment.new ( name = $ . _config . myApplication . name , replicas = 1 , containers = [ k . util . java . container . new ( $ . _config . myApplication . name , $ . _config . myApplication . image ) + k . core . v1 . container . withEnvMixin ([ { name : 'SPRING_DATASOURCE_PASSWORD' , valueFrom : { secretKeyRef : $._config.myApplication.dbPasswordRef }, }, { name : 'SPRING_DATASOURCE_USERNAME' , value : $._config.myApplication.dbUser , }, { name : 'SPRING_DATASOURCE_URL' , value : $._config.myApplication.dbUrl , }, ]), ] ), service : k.util.serviceFor ( self . deployment ), route : k.util.routeFor ( self . service , 'hello.example.com' ), }, } In the last step, we fill the new config parameters with values. ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ) + ( import 'test-java.libsonnet' ) + { _config +: { mariadb +: { user : 'application-user' , password : 'hunter2' , database : 'my-application' , }, myApplication +: { image : 'helloworld:latest' , dbUser : $._config.mariadb.user , dbPasswordRef : $.mariadb.passwordSecretKeyRef , dbUrl : 'jdbc:mysql://' + $ . mariadb . service . metadata . name + '/' + $ . _config . mariadb . database , }, }, mariadb2 : ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ) + { _config +: { mariadb +: { name : 'foo' , user : 'foo-user' , password : 'foo-user' , }, }, }, } And we're done! To recap: we have configured an application, added a database and connected it to our application. The way we connected the applications is transparent, and we could (as long as the application supports it) change the database entirely in our main.jsonnet . This way, we can use different database setups across environment, while keeping the application configuration the same. For more information, check out the documentation of the java utilities and the MariaDB module .","title":"Quick start"},{"location":"guides/quickstart/#quick-start","text":"","title":"Quick start"},{"location":"guides/quickstart/#setting-up","text":"To start using this library, first initialize the working directory using tk init . This will create a directory structure similar to this: . \u251c\u2500\u2500 environments \u2502 \u2514\u2500\u2500 default \u251c\u2500\u2500 jsonnetfile.json \u251c\u2500\u2500 jsonnetfile.lock.json \u251c\u2500\u2500 lib \u2502 \u2514\u2500\u2500 k.libsonnet \u2514\u2500\u2500 vendor \u251c\u2500\u2500 1.23 -> github.com/jsonnet-libs/k8s-libsonnet/1.23 \u251c\u2500\u2500 github.com \u2514\u2500\u2500 ksonnet-util -> github.com/grafana/jsonnet-libs/ksonnet-util Next, we need to install the cloudflight-libsonnet library using jb : jb install github.com/cloudflightio/cloudflight-libsonnet@main The last step is to adapt the predefined k.libsonnet . When initializing, Tanka simply imports the k8s-libsonnet library here. Since some of our customizations depend on other libraries which have to be imported at this point (such as openshift-libsonnet or prometheus-libsonnet ), you replace the contents of k.libsonnet with the following: import 'github.com/cloudflightio/cloudflight-libsonnet/k.libsonnet'","title":"Setting up"},{"location":"guides/quickstart/#using-the-library","text":"To use the components provided by this library (or other Kubernetes components), import our prelude.libsonnet . Let's use the library to deploy a simple java based application, backed by an MariaDB instance.","title":"Using the library"},{"location":"guides/quickstart/#creating-the-application","text":"Applications should be defined in the lib folder. To configure a java application, we create a file called lib/test-java.libsonnet with the contents below. local k = ( import 'cloudflight-libsonnet/prelude.libsonnet' ); { _config +:: { myApplication : { name : 'my-application' , image : error '$._config.myApplication.image must be defined' , }, }, myApplication : { deployment : k.util.java.deployment.new ( name = $ . _config . myApplication . name , image = $ . _config . myApplication . image ), service : k.util.serviceFor ( self . deployment ), route : k.util.routeFor ( self . service , 'hello.example.com' ), }, } Now we can import this into our environment file environments/default/main.jsonnet ( import 'test-java.libsonnet' ) + { _config +: { myApplication +: { image : 'helloworld:latest' , }, }, } Provided your .kube/config and environments/default/spec.json are set up correctly, you can deploy this by running tk apply environments/default .","title":"Creating the application"},{"location":"guides/quickstart/#adding-the-database","text":"Most applications want to store data somewhere so let's add a database next. First, we import the database of choice in the main.jsonnet file. ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ) + ( import 'test-java.libsonnet' ) + { _config +: { mariadb +: { user : 'application-user' , password : 'hunter2' , database : 'my-application' , }, myApplication +: { image : 'helloworld:latest' , }, }, } To connect our application to the database, we need to configure the deployment on a lower level. This is because of the fact, that the plain util.java.deployment does not make any assumptions about databases. As documented in the java module, we build the deployment ourselves, but mix in some environment variables. local k = ( import 'cloudflight-libsonnet/prelude.libsonnet' ); { _config +:: { myApplication : { name : 'my-application' , image : error '$._config.myApplication.image must be defined' , dbUser : error '$._config.myApplication.dbUser must be defined' , dbPasswordRef : error '$._config.myApplication.dbPasswordRef must be a valid secretSecretKeyRef' , dbUrl : error '$._config.myApplication.dbUrl must be defined' , }, }, myApplication : { deployment : k.apps.v1.deployment.new ( name = $ . _config . myApplication . name , replicas = 1 , containers = [ k . util . java . container . new ( $ . _config . myApplication . name , $ . _config . myApplication . image ) + k . core . v1 . container . withEnvMixin ([ { name : 'SPRING_DATASOURCE_PASSWORD' , valueFrom : { secretKeyRef : $._config.myApplication.dbPasswordRef }, }, { name : 'SPRING_DATASOURCE_USERNAME' , value : $._config.myApplication.dbUser , }, { name : 'SPRING_DATASOURCE_URL' , value : $._config.myApplication.dbUrl , }, ]), ] ), service : k.util.serviceFor ( self . deployment ), route : k.util.routeFor ( self . service , 'hello.example.com' ), }, } In the last step, we fill the new config parameters with values. ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ) + ( import 'test-java.libsonnet' ) + { _config +: { mariadb +: { user : 'application-user' , password : 'hunter2' , database : 'my-application' , }, myApplication +: { image : 'helloworld:latest' , dbUser : $._config.mariadb.user , dbPasswordRef : $.mariadb.passwordSecretKeyRef , dbUrl : 'jdbc:mysql://' + $ . mariadb . service . metadata . name + '/' + $ . _config . mariadb . database , }, }, mariadb2 : ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ) + { _config +: { mariadb +: { name : 'foo' , user : 'foo-user' , password : 'foo-user' , }, }, }, } And we're done! To recap: we have configured an application, added a database and connected it to our application. The way we connected the applications is transparent, and we could (as long as the application supports it) change the database entirely in our main.jsonnet . This way, we can use different database setups across environment, while keeping the application configuration the same. For more information, check out the documentation of the java utilities and the MariaDB module .","title":"Adding the database"},{"location":"guides/tanka_migration/","text":"Migrating to Tanka At Cloudflight we were previously using kubecfg to deploy our applications. As of 2022-02-21 , tanka is our recommended tool for Kubernetes configurations. Reasoning for this can be found in ADR-0077. If you're still using kubecfg you're in Luck! The migration to Tanka is very simple and can be done in under five minutes. Tip TL;DR: Move stage files to environments/$NAME/main.jsonnet Create environments/$NAME/spec.json Fix Imports Verifying your current setup Before we can start to migrate to the new setup, we should be confident in the old one to avoid issues further down the line. As a requirement, you should be able to view your configuration in the yaml format by running kubecfg show $YOUR_STAGE_FILE Restructuring The main change required for a smooth workflow in Tanka, is a small restructuring of the directory. Our old layout prescribes a flat structure with everything in the root directory. Tanka on the other hand expects a folder per environment. To perform this step, you need to go from this: . \u251c\u2500\u2500 jsonnetfile.json \u251c\u2500\u2500 production.jsonnet \u251c\u2500\u2500 resources \u2502 \u2514\u2500\u2500 application.jsonnet \u2514\u2500\u2500 staging.jsonnet to . \u251c\u2500\u2500 jsonnetfile.json \u251c\u2500\u2500 environments \u2502 \u251c\u2500\u2500 production \u2502 \u2502 \u2514\u2500\u2500 main.jsonnet # (1) \u2502 \u2514\u2500\u2500 staging \u2502 \u2514\u2500\u2500 main.jsonnet # (2) \u2514\u2500\u2500 lib \u2514\u2500\u2500 application.libsonnet The old production.jsonnet The old staging.jsonnet Configuring Instead of relying on the current Kubernetes context, Tanka needs explicit information on the API Server as well as the namespace. This information is saved in the spec.json file, contained in the respective environment. The complete layout can be found in the Tanka documentation The syntax is as follows: { \"apiVersion\" : \"tanka.dev/v1alpha1\" , \"kind\" : \"Environment\" , \"metadata\" : { \"name\" : \"environments/staging\" }, \"spec\" : { \"apiServer\" : \"openshift-dev.internal.cloudflight.io:6443\" , // (1) \"namespace\" : \"762-example-staging\" , // (2) \"resourceDefaults\" : {}, \"expectVersions\" : {}, \"injectLabels\" : true } } API server URL. Excluding theh protocol, including the port Namespace of your project. Will be injected to all resources Fixing Imports Now that you moved around the files, you will also need to fix the imports contained within them. For convenience, Tanka automatically includes the lib and vendor directory in the jsonnet path. So instead of having to write ../../lib/application.libsonnet you can simply import application.libsonnet . Verifying the new configuration After fixing the imports, you can show the new configuration with the following command: tk show environments/staging TeamCity Tanka integration from TeamCity is supported from version 3.0.0 of the cloudflight-teamcity-dsl onwards. Example: subCloudflightProject { name = \"Deployment\" tankaApply { openShiftConfig { serviceAccountToken = \"credentialsJSON:...\" } contextDir = \".openshift\" // (1) } } Default: deployment as is the case with our new configuration skeleton","title":"Migrating to Tanka"},{"location":"guides/tanka_migration/#migrating-to-tanka","text":"At Cloudflight we were previously using kubecfg to deploy our applications. As of 2022-02-21 , tanka is our recommended tool for Kubernetes configurations. Reasoning for this can be found in ADR-0077. If you're still using kubecfg you're in Luck! The migration to Tanka is very simple and can be done in under five minutes. Tip TL;DR: Move stage files to environments/$NAME/main.jsonnet Create environments/$NAME/spec.json Fix Imports","title":"Migrating to Tanka"},{"location":"guides/tanka_migration/#verifying-your-current-setup","text":"Before we can start to migrate to the new setup, we should be confident in the old one to avoid issues further down the line. As a requirement, you should be able to view your configuration in the yaml format by running kubecfg show $YOUR_STAGE_FILE","title":"Verifying your current setup"},{"location":"guides/tanka_migration/#restructuring","text":"The main change required for a smooth workflow in Tanka, is a small restructuring of the directory. Our old layout prescribes a flat structure with everything in the root directory. Tanka on the other hand expects a folder per environment. To perform this step, you need to go from this: . \u251c\u2500\u2500 jsonnetfile.json \u251c\u2500\u2500 production.jsonnet \u251c\u2500\u2500 resources \u2502 \u2514\u2500\u2500 application.jsonnet \u2514\u2500\u2500 staging.jsonnet to . \u251c\u2500\u2500 jsonnetfile.json \u251c\u2500\u2500 environments \u2502 \u251c\u2500\u2500 production \u2502 \u2502 \u2514\u2500\u2500 main.jsonnet # (1) \u2502 \u2514\u2500\u2500 staging \u2502 \u2514\u2500\u2500 main.jsonnet # (2) \u2514\u2500\u2500 lib \u2514\u2500\u2500 application.libsonnet The old production.jsonnet The old staging.jsonnet","title":"Restructuring"},{"location":"guides/tanka_migration/#configuring","text":"Instead of relying on the current Kubernetes context, Tanka needs explicit information on the API Server as well as the namespace. This information is saved in the spec.json file, contained in the respective environment. The complete layout can be found in the Tanka documentation The syntax is as follows: { \"apiVersion\" : \"tanka.dev/v1alpha1\" , \"kind\" : \"Environment\" , \"metadata\" : { \"name\" : \"environments/staging\" }, \"spec\" : { \"apiServer\" : \"openshift-dev.internal.cloudflight.io:6443\" , // (1) \"namespace\" : \"762-example-staging\" , // (2) \"resourceDefaults\" : {}, \"expectVersions\" : {}, \"injectLabels\" : true } } API server URL. Excluding theh protocol, including the port Namespace of your project. Will be injected to all resources","title":"Configuring"},{"location":"guides/tanka_migration/#fixing-imports","text":"Now that you moved around the files, you will also need to fix the imports contained within them. For convenience, Tanka automatically includes the lib and vendor directory in the jsonnet path. So instead of having to write ../../lib/application.libsonnet you can simply import application.libsonnet .","title":"Fixing Imports"},{"location":"guides/tanka_migration/#verifying-the-new-configuration","text":"After fixing the imports, you can show the new configuration with the following command: tk show environments/staging","title":"Verifying the new configuration"},{"location":"guides/tanka_migration/#teamcity","text":"Tanka integration from TeamCity is supported from version 3.0.0 of the cloudflight-teamcity-dsl onwards. Example: subCloudflightProject { name = \"Deployment\" tankaApply { openShiftConfig { serviceAccountToken = \"credentialsJSON:...\" } contextDir = \".openshift\" // (1) } } Default: deployment as is the case with our new configuration skeleton","title":"TeamCity"},{"location":"library/","text":"cloudflight-libsonnet This library contains various utility modules for use with the jsonnet configuration language To get started, import the provided prelude which will composit the library for you. local k = import ( 'cloudflight-libsonnet/prelude.libsonnet' ); The prelude depends on a file called k.libsonnet being available for import. Either place it in your lib or environment folder. Using the environment folder allows for library level configuration options to be applied on an environment level. This works, because import paths are ranked as highlighted in the Tanka documentation . A pre-populated k.libsonnet is available in this library so a minimal k.libsonnet would look like this: ( import 'cloudflight-libsonnet/k.libsonnet' ) This includes k8s-libsonnet , openshift-libsonnet as well as prometheus-libsonnet For more information on customization options in k.libsonnet , take a look at the labeling extension. extensions labeling networking route util","title":"cloudflight-libsonnet"},{"location":"library/#cloudflight-libsonnet","text":"This library contains various utility modules for use with the jsonnet configuration language To get started, import the provided prelude which will composit the library for you. local k = import ( 'cloudflight-libsonnet/prelude.libsonnet' ); The prelude depends on a file called k.libsonnet being available for import. Either place it in your lib or environment folder. Using the environment folder allows for library level configuration options to be applied on an environment level. This works, because import paths are ranked as highlighted in the Tanka documentation . A pre-populated k.libsonnet is available in this library so a minimal k.libsonnet would look like this: ( import 'cloudflight-libsonnet/k.libsonnet' ) This includes k8s-libsonnet , openshift-libsonnet as well as prometheus-libsonnet For more information on customization options in k.libsonnet , take a look at the labeling extension. extensions labeling networking route util","title":"cloudflight-libsonnet"},{"location":"library/extensions/","text":"extensions Extensions available to the standard library","title":"extensions"},{"location":"library/extensions/#extensions","text":"Extensions available to the standard library","title":"extensions"},{"location":"library/labeling/","text":"labeling This extension allows you to label core kubernetes resources with useful labels. Usage To use this labeling function, edit your k.libsonnet to look something like this ( import 'cloudflight-libsonnet/k.libsonnet' ) + { _config +:: { project : 'some-project-name' } } Afterwards, all resources created (provided they use cloudflight-libsonnet/prelude.libsonnet ), will have the cloudflight.io/project=some-project-name label attached If you need to set this on a per-environment basis, move the k.libsonnet file to your environment folder as described in the Tanka documentation .","title":"labeling"},{"location":"library/labeling/#labeling","text":"This extension allows you to label core kubernetes resources with useful labels.","title":"labeling"},{"location":"library/labeling/#usage","text":"To use this labeling function, edit your k.libsonnet to look something like this ( import 'cloudflight-libsonnet/k.libsonnet' ) + { _config +:: { project : 'some-project-name' } } Afterwards, all resources created (provided they use cloudflight-libsonnet/prelude.libsonnet ), will have the cloudflight.io/project=some-project-name label attached If you need to set this on a per-environment basis, move the k.libsonnet file to your environment folder as described in the Tanka documentation .","title":"Usage"},{"location":"library/networking/","text":"networking Contains extensions related to cert-manager Index obj v1 obj v1.ingress fn withCertMixin(issuer, clusterwide) Fields obj v1 obj v1.ingress fn v1.ingress.withCertMixin withCertMixin ( issuer , clusterwide ) withCertMixin instructs cert-manager to add an certificate to the ingress-resource.","title":"networking"},{"location":"library/networking/#networking","text":"Contains extensions related to cert-manager","title":"networking"},{"location":"library/networking/#index","text":"obj v1 obj v1.ingress fn withCertMixin(issuer, clusterwide)","title":"Index"},{"location":"library/networking/#fields","text":"","title":"Fields"},{"location":"library/networking/#obj-v1","text":"","title":"obj v1"},{"location":"library/networking/#obj-v1ingress","text":"","title":"obj v1.ingress"},{"location":"library/networking/#fn-v1ingresswithcertmixin","text":"withCertMixin ( issuer , clusterwide ) withCertMixin instructs cert-manager to add an certificate to the ingress-resource.","title":"fn v1.ingress.withCertMixin"},{"location":"library/route/","text":"route Contains extensions to the default route functions provided by openshift-libsonnet Index obj v1 obj v1.route fn new(name, host, path) Fields obj v1 obj v1.route fn v1.route.new new ( name , host , path ) builds a route with a predefined host and TLS Edge termination","title":"route"},{"location":"library/route/#route","text":"Contains extensions to the default route functions provided by openshift-libsonnet","title":"route"},{"location":"library/route/#index","text":"obj v1 obj v1.route fn new(name, host, path)","title":"Index"},{"location":"library/route/#fields","text":"","title":"Fields"},{"location":"library/route/#obj-v1","text":"","title":"obj v1"},{"location":"library/route/#obj-v1route","text":"","title":"obj v1.route"},{"location":"library/route/#fn-v1routenew","text":"new ( name , host , path ) builds a route with a predefined host and TLS Edge termination","title":"fn v1.route.new"},{"location":"library/util/","text":"util The util package contains ease of use functions to simplify working with kubernetes and jsonnet Index fn ingressFor(service, port='', path='/', port='service.spec.ports[0].port') fn routeFor(service, port='', path='/', port='service.spec.ports[0].port') fn serviceFor(deployment, ignored_labels, nameFormat='%(port)s') obj certmanager obj certmanager.issuer fn new(emain, ingressClassName='nginx', production=true, clusterwide=true, name='letsencrypt-production || letsencrypt-staging') obj java obj java.container fn new(name, image, port=8080, actuatorPort='port+8080', env={}) obj java.deployment fn new(name, image, replicas=1, env={}, runtime='spring-boot', component='backend') obj java.livenessProbe fn new(port=8080, initialDelaySeconds=30) obj java.readinessProbe fn new(port=18080, path='/actuator/health') obj openshiftOAuth obj openshiftOAuth.container fn new(upstream, serviceAccount) obj openshiftOAuth.deployment fn withProxy(upstream, serviceAccount) obj openshiftOAuth.serviceAccount fn new(name, route) Fields fn ingressFor ingressFor ( service , port = '' , path = '/' , port = 'service.spec.ports[0].port' ) ingressFor constructs a ingress object, compatible with the automatic translation to openshift routes. It expects a value for the hostname and defaults to '/' for the path. fn routeFor routeFor ( service , port = '' , path = '/' , port = 'service.spec.ports[0].port' ) routeFor constructs a openshift route to the specified service. It expects a value for the hostname and defaults to '/' for the path. fn serviceFor serviceFor ( deployment , ignored_labels , nameFormat = '%(port)s' ) serviceFor constructs a service for the specified deployment. Selector labels are taken from the pod spec but can be ignored using the ignored_labels parameter. The ports of the service will have the same name as in the container spec to avoid confusion. This can be changed with the nameFormat parameter. obj certmanager certman holds functions related to cert-manager (cert-manager.io) obj certmanager.issuer fn certmanager.issuer.new new ( emain , ingressClassName = 'nginx' , production = true , clusterwide = true , name = 'letsencrypt-production || letsencrypt-staging' ) constructs a cert-manager issuer resource for letsencrypt with sensible default. obj java java holds my functions related to java based applications obj java.container fn java.container.new new ( name , image , port = 8080 , actuatorPort = 'port+8080' , env = {}) constructs a container with reccomended settings for Java/Spring Boot applications. Includes liveness- and readiness probes, activates the kubernetes spring profile and sets sensible resource defaults. obj java.deployment fn java.deployment.new new ( name , image , replicas = 1 , env = {}, runtime = 'spring-boot' , component = 'backend' ) constructs a deployment using the java container. If you need more control, construct this deployment yourself. The runtime and component parameters are used to prefill reccomended labels obj java.livenessProbe fn java.livenessProbe.new new ( port = 8080 , initialDelaySeconds = 30 ) new constructs a fresh liveness probe, checking if the tcp port 8080 is open obj java.readinessProbe fn java.readinessProbe.new new ( port = 18080 , path = '/actuator/health' ) new constructs a fresh readiness probe, checking if the application is up. The port and path of the actuator endpoint can be changed using the parameters. obj openshiftOAuth openshiftOAuth contains utilities to proxy an application using the OpenShift OAuth Proxy obj openshiftOAuth.container fn openshiftOAuth.container.new new ( upstream , serviceAccount ) constructs a container proxying connections to the upstream parameter. obj openshiftOAuth.deployment fn openshiftOAuth.deployment.withProxy withProxy ( upstream , serviceAccount ) add a proxy sidecar to the container. This also sets the service account used by the pod. The ServiceAccount needs to have the correct redirect reference for the route. See openshiftOAuth.serviceAccount.new for an easy way to create a compliant service account obj openshiftOAuth.serviceAccount fn openshiftOAuth.serviceAccount.new new ( name , route ) constructs a serviceaccount annotated with a oauth-redirectreference pointing to the route parameter","title":"util"},{"location":"library/util/#util","text":"The util package contains ease of use functions to simplify working with kubernetes and jsonnet","title":"util"},{"location":"library/util/#index","text":"fn ingressFor(service, port='', path='/', port='service.spec.ports[0].port') fn routeFor(service, port='', path='/', port='service.spec.ports[0].port') fn serviceFor(deployment, ignored_labels, nameFormat='%(port)s') obj certmanager obj certmanager.issuer fn new(emain, ingressClassName='nginx', production=true, clusterwide=true, name='letsencrypt-production || letsencrypt-staging') obj java obj java.container fn new(name, image, port=8080, actuatorPort='port+8080', env={}) obj java.deployment fn new(name, image, replicas=1, env={}, runtime='spring-boot', component='backend') obj java.livenessProbe fn new(port=8080, initialDelaySeconds=30) obj java.readinessProbe fn new(port=18080, path='/actuator/health') obj openshiftOAuth obj openshiftOAuth.container fn new(upstream, serviceAccount) obj openshiftOAuth.deployment fn withProxy(upstream, serviceAccount) obj openshiftOAuth.serviceAccount fn new(name, route)","title":"Index"},{"location":"library/util/#fields","text":"","title":"Fields"},{"location":"library/util/#fn-ingressfor","text":"ingressFor ( service , port = '' , path = '/' , port = 'service.spec.ports[0].port' ) ingressFor constructs a ingress object, compatible with the automatic translation to openshift routes. It expects a value for the hostname and defaults to '/' for the path.","title":"fn ingressFor"},{"location":"library/util/#fn-routefor","text":"routeFor ( service , port = '' , path = '/' , port = 'service.spec.ports[0].port' ) routeFor constructs a openshift route to the specified service. It expects a value for the hostname and defaults to '/' for the path.","title":"fn routeFor"},{"location":"library/util/#fn-servicefor","text":"serviceFor ( deployment , ignored_labels , nameFormat = '%(port)s' ) serviceFor constructs a service for the specified deployment. Selector labels are taken from the pod spec but can be ignored using the ignored_labels parameter. The ports of the service will have the same name as in the container spec to avoid confusion. This can be changed with the nameFormat parameter.","title":"fn serviceFor"},{"location":"library/util/#obj-certmanager","text":"certman holds functions related to cert-manager (cert-manager.io)","title":"obj certmanager"},{"location":"library/util/#obj-certmanagerissuer","text":"","title":"obj certmanager.issuer"},{"location":"library/util/#fn-certmanagerissuernew","text":"new ( emain , ingressClassName = 'nginx' , production = true , clusterwide = true , name = 'letsencrypt-production || letsencrypt-staging' ) constructs a cert-manager issuer resource for letsencrypt with sensible default.","title":"fn certmanager.issuer.new"},{"location":"library/util/#obj-java","text":"java holds my functions related to java based applications","title":"obj java"},{"location":"library/util/#obj-javacontainer","text":"","title":"obj java.container"},{"location":"library/util/#fn-javacontainernew","text":"new ( name , image , port = 8080 , actuatorPort = 'port+8080' , env = {}) constructs a container with reccomended settings for Java/Spring Boot applications. Includes liveness- and readiness probes, activates the kubernetes spring profile and sets sensible resource defaults.","title":"fn java.container.new"},{"location":"library/util/#obj-javadeployment","text":"","title":"obj java.deployment"},{"location":"library/util/#fn-javadeploymentnew","text":"new ( name , image , replicas = 1 , env = {}, runtime = 'spring-boot' , component = 'backend' ) constructs a deployment using the java container. If you need more control, construct this deployment yourself. The runtime and component parameters are used to prefill reccomended labels","title":"fn java.deployment.new"},{"location":"library/util/#obj-javalivenessprobe","text":"","title":"obj java.livenessProbe"},{"location":"library/util/#fn-javalivenessprobenew","text":"new ( port = 8080 , initialDelaySeconds = 30 ) new constructs a fresh liveness probe, checking if the tcp port 8080 is open","title":"fn java.livenessProbe.new"},{"location":"library/util/#obj-javareadinessprobe","text":"","title":"obj java.readinessProbe"},{"location":"library/util/#fn-javareadinessprobenew","text":"new ( port = 18080 , path = '/actuator/health' ) new constructs a fresh readiness probe, checking if the application is up. The port and path of the actuator endpoint can be changed using the parameters.","title":"fn java.readinessProbe.new"},{"location":"library/util/#obj-openshiftoauth","text":"openshiftOAuth contains utilities to proxy an application using the OpenShift OAuth Proxy","title":"obj openshiftOAuth"},{"location":"library/util/#obj-openshiftoauthcontainer","text":"","title":"obj openshiftOAuth.container"},{"location":"library/util/#fn-openshiftoauthcontainernew","text":"new ( upstream , serviceAccount ) constructs a container proxying connections to the upstream parameter.","title":"fn openshiftOAuth.container.new"},{"location":"library/util/#obj-openshiftoauthdeployment","text":"","title":"obj openshiftOAuth.deployment"},{"location":"library/util/#fn-openshiftoauthdeploymentwithproxy","text":"withProxy ( upstream , serviceAccount ) add a proxy sidecar to the container. This also sets the service account used by the pod. The ServiceAccount needs to have the correct redirect reference for the route. See openshiftOAuth.serviceAccount.new for an easy way to create a compliant service account","title":"fn openshiftOAuth.deployment.withProxy"},{"location":"library/util/#obj-openshiftoauthserviceaccount","text":"","title":"obj openshiftOAuth.serviceAccount"},{"location":"library/util/#fn-openshiftoauthserviceaccountnew","text":"new ( name , route ) constructs a serviceaccount annotated with a oauth-redirectreference pointing to the route parameter","title":"fn openshiftOAuth.serviceAccount.new"},{"location":"modules/","text":"What are modules? Modules are ready-to-use setups of existing applications and services. To use them, import them into your main.libsonnet like so: ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ) + { _config +: { mariadb +: { user : 'foo' , password : 'bar' , } } }","title":"What are modules?"},{"location":"modules/#what-are-modules","text":"Modules are ready-to-use setups of existing applications and services. To use them, import them into your main.libsonnet like so: ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ) + { _config +: { mariadb +: { user : 'foo' , password : 'bar' , } } }","title":"What are modules?"},{"location":"modules/java_application/","text":"Java Applications Even though not strictly a module, this library contains a lot of utility functions to help you deploy Java applications. This page contains some ways these functions can be used. All-in-one This example contains the deployment of a simple spring boot based application. It should be located somewhere like lib/my-application.libsonnet . jsonnet yaml local k = ( import 'cloudflight-libsonnet/prelude.libsonnet' ); { _config +:: { myApplication : { name : 'my-application' , image : error '$._config.myApplication.image must be defined' , }, }, myApplication : { deployment : k.util.java.deployment.new ( name = $ . _config . myApplication . name , image = $ . _config . myApplication . image ), service : k.util.serviceFor ( self . deployment ), route : k.util.routeFor ( self . service , 'hello.example.com' ), }, } apiVersion : v1 kind : Service metadata : labels : name : my-application name : my-application namespace : test-java spec : ports : - name : my-application-http port : 8080 targetPort : 8080 - name : my-application-actuator port : 9080 targetPort : 9080 selector : name : my-application --- apiVersion : apps/v1 kind : Deployment metadata : name : my-application namespace : test-java spec : minReadySeconds : 10 replicas : 1 revisionHistoryLimit : 10 selector : matchLabels : name : my-application template : metadata : labels : name : my-application spec : containers : - env : - name : SPRING_PROFILES_ACTIVE value : kubernetes image : helloworld:latest imagePullPolicy : IfNotPresent livenessProbe : failureThreshold : 5 initialDelaySeconds : 30 periodSeconds : 10 successThreshold : 1 tcpSocket : port : 8080 timeoutSeconds : 1 name : my-application ports : - containerPort : 8080 name : http - containerPort : 9080 name : actuator readinessProbe : failureThreshold : 5 httpGet : path : /actuator/health port : 18080 initialDelaySeconds : 30 periodSeconds : 10 successThreshold : 1 timeoutSeconds : 1 resources : limits : cpu : 500m memory : 1Gi requests : cpu : 100m memory : 1Gi --- apiVersion : route.openshift.io/v1 kind : Route metadata : name : my-application namespace : test-java spec : host : hello.example.com path : / port : targetPort : 8080 tls : insecureEdgeTerminationPolicy : Redirect termination : Edge to : kind : Service name : my-application Switch between the tabs to see the rendered output DIY If you have the need for further customization, you can pick and choose parts of the library you would like to use. In this example, we want to modify the container so we use the util.java.container.new() to get a base structure and extend it. This way, we still have the defaults set, but are able to customize them to our hearts content. jsonnet yaml local k = ( import 'cloudflight-libsonnet/prelude.libsonnet' ); { _config +:: { myApplication : { name : 'my-application' , image : error '$._config.myApplication.image must be defined' , }, }, myApplication : { deployment : k.apps.v1.deployment.new ( name = $ . _config . myApplication . name , replicas = 2 , containers = [ k . util . java . container . new ( $ . _config . myApplication . name , $ . _config . myApplication . image ) + k . core . v1 . container . withVolumeMounts ([ k . core . v1 . volumeMount . new ( name = 'temp' , mountPath = '/opt/cache' ), ]), ] ) + k . apps . v1 . deployment . spec . template . spec . withVolumes ([ k . core . v1 . volume . fromEmptyDir ( name = 'temp' ), ]), service : k.util.serviceFor ( self . deployment ), route : k.util.routeFor ( self . service , 'hello.example.com' ), }, } apiVersion : v1 kind : Service metadata : labels : name : my-application name : my-application namespace : test-java-diy spec : ports : - name : my-application-http port : 8080 targetPort : 8080 - name : my-application-actuator port : 9080 targetPort : 9080 selector : name : my-application --- apiVersion : apps/v1 kind : Deployment metadata : name : my-application namespace : test-java-diy spec : minReadySeconds : 10 replicas : 2 revisionHistoryLimit : 10 selector : matchLabels : name : my-application template : metadata : labels : name : my-application spec : containers : - env : - name : SPRING_PROFILES_ACTIVE value : kubernetes image : helloworld:latest imagePullPolicy : IfNotPresent livenessProbe : failureThreshold : 5 initialDelaySeconds : 30 periodSeconds : 10 successThreshold : 1 tcpSocket : port : 8080 timeoutSeconds : 1 name : my-application ports : - containerPort : 8080 name : http - containerPort : 9080 name : actuator readinessProbe : failureThreshold : 5 httpGet : path : /actuator/health port : 18080 initialDelaySeconds : 30 periodSeconds : 10 successThreshold : 1 timeoutSeconds : 1 resources : limits : cpu : 500m memory : 1Gi requests : cpu : 100m memory : 1Gi volumeMounts : - mountPath : /opt/cache name : temp volumes : - emptyDir : {} name : temp --- apiVersion : route.openshift.io/v1 kind : Route metadata : name : my-application namespace : test-java-diy spec : host : hello.example.com path : / port : targetPort : 8080 tls : insecureEdgeTerminationPolicy : Redirect termination : Edge to : kind : Service name : my-application","title":"Java Applications"},{"location":"modules/java_application/#java-applications","text":"Even though not strictly a module, this library contains a lot of utility functions to help you deploy Java applications. This page contains some ways these functions can be used.","title":"Java Applications"},{"location":"modules/java_application/#all-in-one","text":"This example contains the deployment of a simple spring boot based application. It should be located somewhere like lib/my-application.libsonnet . jsonnet yaml local k = ( import 'cloudflight-libsonnet/prelude.libsonnet' ); { _config +:: { myApplication : { name : 'my-application' , image : error '$._config.myApplication.image must be defined' , }, }, myApplication : { deployment : k.util.java.deployment.new ( name = $ . _config . myApplication . name , image = $ . _config . myApplication . image ), service : k.util.serviceFor ( self . deployment ), route : k.util.routeFor ( self . service , 'hello.example.com' ), }, } apiVersion : v1 kind : Service metadata : labels : name : my-application name : my-application namespace : test-java spec : ports : - name : my-application-http port : 8080 targetPort : 8080 - name : my-application-actuator port : 9080 targetPort : 9080 selector : name : my-application --- apiVersion : apps/v1 kind : Deployment metadata : name : my-application namespace : test-java spec : minReadySeconds : 10 replicas : 1 revisionHistoryLimit : 10 selector : matchLabels : name : my-application template : metadata : labels : name : my-application spec : containers : - env : - name : SPRING_PROFILES_ACTIVE value : kubernetes image : helloworld:latest imagePullPolicy : IfNotPresent livenessProbe : failureThreshold : 5 initialDelaySeconds : 30 periodSeconds : 10 successThreshold : 1 tcpSocket : port : 8080 timeoutSeconds : 1 name : my-application ports : - containerPort : 8080 name : http - containerPort : 9080 name : actuator readinessProbe : failureThreshold : 5 httpGet : path : /actuator/health port : 18080 initialDelaySeconds : 30 periodSeconds : 10 successThreshold : 1 timeoutSeconds : 1 resources : limits : cpu : 500m memory : 1Gi requests : cpu : 100m memory : 1Gi --- apiVersion : route.openshift.io/v1 kind : Route metadata : name : my-application namespace : test-java spec : host : hello.example.com path : / port : targetPort : 8080 tls : insecureEdgeTerminationPolicy : Redirect termination : Edge to : kind : Service name : my-application Switch between the tabs to see the rendered output","title":"All-in-one"},{"location":"modules/java_application/#diy","text":"If you have the need for further customization, you can pick and choose parts of the library you would like to use. In this example, we want to modify the container so we use the util.java.container.new() to get a base structure and extend it. This way, we still have the defaults set, but are able to customize them to our hearts content. jsonnet yaml local k = ( import 'cloudflight-libsonnet/prelude.libsonnet' ); { _config +:: { myApplication : { name : 'my-application' , image : error '$._config.myApplication.image must be defined' , }, }, myApplication : { deployment : k.apps.v1.deployment.new ( name = $ . _config . myApplication . name , replicas = 2 , containers = [ k . util . java . container . new ( $ . _config . myApplication . name , $ . _config . myApplication . image ) + k . core . v1 . container . withVolumeMounts ([ k . core . v1 . volumeMount . new ( name = 'temp' , mountPath = '/opt/cache' ), ]), ] ) + k . apps . v1 . deployment . spec . template . spec . withVolumes ([ k . core . v1 . volume . fromEmptyDir ( name = 'temp' ), ]), service : k.util.serviceFor ( self . deployment ), route : k.util.routeFor ( self . service , 'hello.example.com' ), }, } apiVersion : v1 kind : Service metadata : labels : name : my-application name : my-application namespace : test-java-diy spec : ports : - name : my-application-http port : 8080 targetPort : 8080 - name : my-application-actuator port : 9080 targetPort : 9080 selector : name : my-application --- apiVersion : apps/v1 kind : Deployment metadata : name : my-application namespace : test-java-diy spec : minReadySeconds : 10 replicas : 2 revisionHistoryLimit : 10 selector : matchLabels : name : my-application template : metadata : labels : name : my-application spec : containers : - env : - name : SPRING_PROFILES_ACTIVE value : kubernetes image : helloworld:latest imagePullPolicy : IfNotPresent livenessProbe : failureThreshold : 5 initialDelaySeconds : 30 periodSeconds : 10 successThreshold : 1 tcpSocket : port : 8080 timeoutSeconds : 1 name : my-application ports : - containerPort : 8080 name : http - containerPort : 9080 name : actuator readinessProbe : failureThreshold : 5 httpGet : path : /actuator/health port : 18080 initialDelaySeconds : 30 periodSeconds : 10 successThreshold : 1 timeoutSeconds : 1 resources : limits : cpu : 500m memory : 1Gi requests : cpu : 100m memory : 1Gi volumeMounts : - mountPath : /opt/cache name : temp volumes : - emptyDir : {} name : temp --- apiVersion : route.openshift.io/v1 kind : Route metadata : name : my-application namespace : test-java-diy spec : host : hello.example.com path : / port : targetPort : 8080 tls : insecureEdgeTerminationPolicy : Redirect termination : Edge to : kind : Service name : my-application","title":"DIY"},{"location":"modules/applications/spring-boot-admin/","text":"Spring Boot Admin This module creates an instance of spring-boot-admin , preconfigured to discover endpoints via Kubernetes. The following snippets lists all available configuration options alongside their default values: ( import 'cloudflight-libsonnet/applications/spring-boot-admin.libsonnet' ) + { _config +: { springBootAdmin : { name : 'spring-boot-admin' , image : 'ghcr.io/cloudflightio/spring-boot-admin-docker:2.7.3' , host : error '$._config.springBootAdmin.host must be defined' , serviceAccountName : 'default' , config : { spring : { cloud : { kubernetes : { discovery : { enabled : true , 'service-labels' : { '[app.openshift.io/runtime]' : 'spring-boot' , }, catalogServiceWatchDelay : 300 , 'primary-port-name' : 'actuator' , }, }, }, }, }, resources :: { limits : { cpu : '500m' , memory : '512Mi' , }, requests : { cpu : '10m' , memory : '512Mi' , }, }, }, } } Integration and Service Discovery When using our java helpers , spring-boot-admin will automatically discover provided services and their respective actuator endpoints. To customize the discovery, modify $._config.springBootAdmin.config.spring.cloud.kubernetes.discovery to match your labels.","title":"Spring Boot Admin"},{"location":"modules/applications/spring-boot-admin/#spring-boot-admin","text":"This module creates an instance of spring-boot-admin , preconfigured to discover endpoints via Kubernetes. The following snippets lists all available configuration options alongside their default values: ( import 'cloudflight-libsonnet/applications/spring-boot-admin.libsonnet' ) + { _config +: { springBootAdmin : { name : 'spring-boot-admin' , image : 'ghcr.io/cloudflightio/spring-boot-admin-docker:2.7.3' , host : error '$._config.springBootAdmin.host must be defined' , serviceAccountName : 'default' , config : { spring : { cloud : { kubernetes : { discovery : { enabled : true , 'service-labels' : { '[app.openshift.io/runtime]' : 'spring-boot' , }, catalogServiceWatchDelay : 300 , 'primary-port-name' : 'actuator' , }, }, }, }, }, resources :: { limits : { cpu : '500m' , memory : '512Mi' , }, requests : { cpu : '10m' , memory : '512Mi' , }, }, }, } }","title":"Spring Boot Admin"},{"location":"modules/applications/spring-boot-admin/#integration-and-service-discovery","text":"When using our java helpers , spring-boot-admin will automatically discover provided services and their respective actuator endpoints. To customize the discovery, modify $._config.springBootAdmin.config.spring.cloud.kubernetes.discovery to match your labels.","title":"Integration and Service Discovery"},{"location":"modules/databases/mariadb/","text":"MariaDB Database Module This module contains a MariaDB instance, located in the mariadb key. The following snippets lists all available configuration options alongside their default values: ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ) + { _config +: { mariadb : { name : 'mariadb' , storage : '5Gi' , user : error 'cfg.user must be defined' , password : error 'cfg.password must be defined' , database : self.user , image : 'registry.redhat.io/rhel8/mariadb-103:1-181' , exporterImage : 'docker.io/prom/mysqld-exporter:v0.14.0' , exporter_password : std.md5 ( self . password ), resources :: { limits : { cpu : '500m' , memory : '2Gi' , }, requests : { cpu : '200m' , memory : '1Gi' , }, }, }, } } Exposed values The following values are exposed, but not exported: Name Contents mariadb.passwordSecretKeyRef A kubernetes secretKeyRef , referencing the user password Starting multiple instances Another way to use this module, is by calling the newMariaDB function. This allows you to create multiple instances without polluting the global scope. { _config +:: { dbOne : { name : 'dbOne' , user : 'foo' , password : 'bar' , }, dbTwo : { name : 'dbTwo' , user : 'foo' , password : 'bar' , } } dbOne : ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ). newMariaDB ( $ . _config . dbOne ), dbTwo : ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ). newMariaDB ( $ . _config . dbTwo ), }","title":"MariaDB Database Module"},{"location":"modules/databases/mariadb/#mariadb-database-module","text":"This module contains a MariaDB instance, located in the mariadb key. The following snippets lists all available configuration options alongside their default values: ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ) + { _config +: { mariadb : { name : 'mariadb' , storage : '5Gi' , user : error 'cfg.user must be defined' , password : error 'cfg.password must be defined' , database : self.user , image : 'registry.redhat.io/rhel8/mariadb-103:1-181' , exporterImage : 'docker.io/prom/mysqld-exporter:v0.14.0' , exporter_password : std.md5 ( self . password ), resources :: { limits : { cpu : '500m' , memory : '2Gi' , }, requests : { cpu : '200m' , memory : '1Gi' , }, }, }, } }","title":"MariaDB Database Module"},{"location":"modules/databases/mariadb/#exposed-values","text":"The following values are exposed, but not exported: Name Contents mariadb.passwordSecretKeyRef A kubernetes secretKeyRef , referencing the user password","title":"Exposed values"},{"location":"modules/databases/mariadb/#starting-multiple-instances","text":"Another way to use this module, is by calling the newMariaDB function. This allows you to create multiple instances without polluting the global scope. { _config +:: { dbOne : { name : 'dbOne' , user : 'foo' , password : 'bar' , }, dbTwo : { name : 'dbTwo' , user : 'foo' , password : 'bar' , } } dbOne : ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ). newMariaDB ( $ . _config . dbOne ), dbTwo : ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ). newMariaDB ( $ . _config . dbTwo ), }","title":"Starting multiple instances"},{"location":"modules/databases/redis/","text":"Redis Cache Module This module contains a Redis Cache, located in the redis key. The following snippets lists all available configuration options alongside their default values: ( import 'cloudflight-libsonnet/databases/redis.libsonnet' ) + { _config +: { redis : { name : 'redis' , image : 'registry.redhat.io/rhel8/redis-6:1-62' , exporterImage : 'docker.io/oliver006/redis_exporter:v1.43.0' , password : error 'cfg.password must either be defined or set to null' , storage : null , resources :: { limits : { cpu : '100m' , memory : '2Gi' , }, requests : { cpu : '50m' , memory : '1Gi' , }, }, }, } } Starting multiple instances Another way to use this module, is by calling the newRedis function. This allows you to create multiple instances without polluting the global scope. { _config +:: { cacheOne : { name : 'cacheOne' , password : 'foo' , }, cacheTwo : { name : 'cacheTwo' , password : 'bar' , } }, cacheOne : ( import 'cloudflight-libsonnet/databases/redis.libsonnet' ). newRedis ( $ . _config . cacheOne ), cacheTwo : ( import 'cloudflight-libsonnet/databases/redis.libsonnet' ). newRedis ( $ . _config . cacheTwo ), }","title":"Redis Cache Module"},{"location":"modules/databases/redis/#redis-cache-module","text":"This module contains a Redis Cache, located in the redis key. The following snippets lists all available configuration options alongside their default values: ( import 'cloudflight-libsonnet/databases/redis.libsonnet' ) + { _config +: { redis : { name : 'redis' , image : 'registry.redhat.io/rhel8/redis-6:1-62' , exporterImage : 'docker.io/oliver006/redis_exporter:v1.43.0' , password : error 'cfg.password must either be defined or set to null' , storage : null , resources :: { limits : { cpu : '100m' , memory : '2Gi' , }, requests : { cpu : '50m' , memory : '1Gi' , }, }, }, } }","title":"Redis Cache Module"},{"location":"modules/databases/redis/#starting-multiple-instances","text":"Another way to use this module, is by calling the newRedis function. This allows you to create multiple instances without polluting the global scope. { _config +:: { cacheOne : { name : 'cacheOne' , password : 'foo' , }, cacheTwo : { name : 'cacheTwo' , password : 'bar' , } }, cacheOne : ( import 'cloudflight-libsonnet/databases/redis.libsonnet' ). newRedis ( $ . _config . cacheOne ), cacheTwo : ( import 'cloudflight-libsonnet/databases/redis.libsonnet' ). newRedis ( $ . _config . cacheTwo ), }","title":"Starting multiple instances"},{"location":"modules/infrastructure/cert-manager/","text":"Cert-Manager Module This adds certmanager (see https://cert-manager.io/), located in the certmanager key. It helpes you issuing and managing certificated using custom k8s resources only. The following snippets lists all available configuration options alongside their default values: ( import 'cloudflight-libsonnet/infrastructure/cert-manager/cert-manager.libsonnet' ) + { _config +: { certmanager : { name : 'cert-manager' , aks : false , }, } } Example ( import 'cloudflight-libsonnet/infrastructure/cert-manager/cert-manager.libsonnet' ) + { _config +: { certmanager : { name : 'cert-manager' , namespace : 'cert-manager' , aks : true , }, }, } Addons There is also a special set of utilities and extensions that can be used to make the setup process easier. This example installs cert-manager, adds a lets-encrypt issuer and a ssl-protected ingress-rule: local k = ( import 'k.libsonnet' ); local ingress = k . networking . v1 . ingress ; ( import 'cloudflight-libsonnet/infrastructure/cert-manager/cert-manager.libsonnet' ) + { issuer : k.util.certmanager.issuer.new ( 'admin@example.com' ), ingress : ingress.new ( 'test.example.com' ) + ingress . withCertMixin ( $ . issuer ), }","title":"Cert-Manager Module"},{"location":"modules/infrastructure/cert-manager/#cert-manager-module","text":"This adds certmanager (see https://cert-manager.io/), located in the certmanager key. It helpes you issuing and managing certificated using custom k8s resources only. The following snippets lists all available configuration options alongside their default values: ( import 'cloudflight-libsonnet/infrastructure/cert-manager/cert-manager.libsonnet' ) + { _config +: { certmanager : { name : 'cert-manager' , aks : false , }, } }","title":"Cert-Manager Module"},{"location":"modules/infrastructure/cert-manager/#example","text":"( import 'cloudflight-libsonnet/infrastructure/cert-manager/cert-manager.libsonnet' ) + { _config +: { certmanager : { name : 'cert-manager' , namespace : 'cert-manager' , aks : true , }, }, }","title":"Example"},{"location":"modules/infrastructure/cert-manager/#addons","text":"There is also a special set of utilities and extensions that can be used to make the setup process easier. This example installs cert-manager, adds a lets-encrypt issuer and a ssl-protected ingress-rule: local k = ( import 'k.libsonnet' ); local ingress = k . networking . v1 . ingress ; ( import 'cloudflight-libsonnet/infrastructure/cert-manager/cert-manager.libsonnet' ) + { issuer : k.util.certmanager.issuer.new ( 'admin@example.com' ), ingress : ingress.new ( 'test.example.com' ) + ingress . withCertMixin ( $ . issuer ), }","title":"Addons"},{"location":"modules/infrastructure/k8s-digester/","text":"k8s-digester Module This module installs the k8s-digester in your cluster. It currently does not offer any customization options and is functionally equivalent to applying the digester_manifest.yaml . The reason for this module is to have everything you need in one place without relying on manual kubectl apply steps.","title":"k8s-digester Module"},{"location":"modules/infrastructure/k8s-digester/#k8s-digester-module","text":"This module installs the k8s-digester in your cluster. It currently does not offer any customization options and is functionally equivalent to applying the digester_manifest.yaml . The reason for this module is to have everything you need in one place without relying on manual kubectl apply steps.","title":"k8s-digester Module"},{"location":"modules/infrastructure/nginx-ingress/","text":"Nginx-Ingress Module This adds nginx-ingress-controller (see https://github.com/kubernetes/ingress-nginx), located in the nginxingress key. This is helpful if no other ingress-controller is deployes (e.g. AKS without API Gateway). The following snippets lists all available configuration options alongside their default values: ( import 'cloudflight-libsonnet/infrastructure/nginx-ingress/nginx-ingress.libsonnet' ) + { _config +: { nginxingress : { name : 'nginx-ingress' , loadBalancerIP : error 'you need a static loadbalancer (public ip)' , }, } }","title":"Nginx-Ingress Module"},{"location":"modules/infrastructure/nginx-ingress/#nginx-ingress-module","text":"This adds nginx-ingress-controller (see https://github.com/kubernetes/ingress-nginx), located in the nginxingress key. This is helpful if no other ingress-controller is deployes (e.g. AKS without API Gateway). The following snippets lists all available configuration options alongside their default values: ( import 'cloudflight-libsonnet/infrastructure/nginx-ingress/nginx-ingress.libsonnet' ) + { _config +: { nginxingress : { name : 'nginx-ingress' , loadBalancerIP : error 'you need a static loadbalancer (public ip)' , }, } }","title":"Nginx-Ingress Module"}]}