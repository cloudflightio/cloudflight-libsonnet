{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Welcome to the documentation of the Cloudflight jsonnet library . This library contains utilities and premade modules to ease working with Kubernets and OpenShift. To get started, take a look at the guides or the module documentation . If you know your way around jsonnet already, why not take a look at our complete library ? If you want support for your editor you should use one of the plugins listed on the tools page. We recommend plugins based on the jsonnet-language server . Info cloudflight-libsonnet is inteded to be used with Tanka . Other tools might work, however we do not test for them. If you're using kubecfg , take a look at our migration guide .","title":"Home"},{"location":"#home","text":"Welcome to the documentation of the Cloudflight jsonnet library . This library contains utilities and premade modules to ease working with Kubernets and OpenShift. To get started, take a look at the guides or the module documentation . If you know your way around jsonnet already, why not take a look at our complete library ? If you want support for your editor you should use one of the plugins listed on the tools page. We recommend plugins based on the jsonnet-language server . Info cloudflight-libsonnet is inteded to be used with Tanka . Other tools might work, however we do not test for them. If you're using kubecfg , take a look at our migration guide .","title":"Home"},{"location":"guides/","text":"This section contains guides for various usecases concerning our jsonnet library. External Resources Jsonnnet Tutorial: https://jsonnet.org/learning/tutorial.html Tanka Tutorial: https://tanka.dev/tutorial/overview k8s-libsonnet: https://jsonnet-libs.github.io/k8s-libsonnet/","title":"Index"},{"location":"guides/#external-resources","text":"Jsonnnet Tutorial: https://jsonnet.org/learning/tutorial.html Tanka Tutorial: https://tanka.dev/tutorial/overview k8s-libsonnet: https://jsonnet-libs.github.io/k8s-libsonnet/","title":"External Resources"},{"location":"guides/tanka_migration/","text":"Migrating to Tanka At Cloudflight we were previously using kubecfg to deploy our applications. As of 2022-02-21 , tanka is our recommended tool for Kubernetes configurations. Reasoning for this can be found in ADR-0077. If you're still using kubecfg you're in Luck! The migration to Tanka is very simple and can be done in under five minutes. Tip TL;DR: Move stage files to environments/$NAME/main.jsonnet Create environments/$NAME/spec.json Fix Imports Verifying your current setup Before we can start to migrate to the new setup, we should be confident in the old one to avoid issues further down the line. As a requirement, you should be able to view your configuration in the yaml format by running kubecfg show $YOUR_STAGE_FILE Restructuring The main change required for a smooth workflow in Tanka, is a small restructuring of the directory. Our old layout prescribes a flat structure with everything in the root directory. Tanka on the other hand expects a folder per environment. To perform this step, you need to go from this: . \u251c\u2500\u2500 jsonnetfile.json \u251c\u2500\u2500 production.jsonnet \u251c\u2500\u2500 resources \u2502 \u2514\u2500\u2500 application.jsonnet \u2514\u2500\u2500 staging.jsonnet to . \u251c\u2500\u2500 jsonnetfile.json \u251c\u2500\u2500 environments \u2502 \u251c\u2500\u2500 production \u2502 \u2502 \u2514\u2500\u2500 main.jsonnet # (1) \u2502 \u2514\u2500\u2500 staging \u2502 \u2514\u2500\u2500 main.jsonnet # (2) \u2514\u2500\u2500 lib \u2514\u2500\u2500 application.libsonnet The old production.jsonnet The old staging.jsonnet Configuring Instead of relying on the current Kubernetes context, Tanka needs explicit information on the API Server as well as the namespace. This information is saved in the spec.json file, contained in the respective environment. The complete layout can be found in the Tanka documentation The syntax is as follows: { \"apiVersion\" : \"tanka.dev/v1alpha1\" , \"kind\" : \"Environment\" , \"metadata\" : { \"name\" : \"environments/staging\" }, \"spec\" : { \"apiServer\" : \"openshift-dev.internal.cloudflight.io:6443\" , // (1) \"namespace\" : \"762-example-staging\" , // (2) \"resourceDefaults\" : {}, \"expectVersions\" : {}, \"injectLabels\" : true } } API server URL. Excluding theh protocol, including the port Namespace of your project. Will be injected to all resources Fixing Imports Now that you moved around the files, you will also need to fix the imports contained within them. For convenience, Tanka automatically includes the lib and vendor directory in the jsonnet path. So instead of having to write ../../lib/application.libsonnet you can simply import application.libsonnet . Verifying the new configuration After fixing the imports, you can show the new configuration with the following command: tk show environments/staging TeamCity Tanka integration from TeamCity is supported from version 3.0.0 of the cloudflight-teamcity-dsl onwards. Example: subCloudflightProject { name = \"Deployment\" tankaApply { openShiftConfig { serviceAccountToken = \"credentialsJSON:...\" } contextDir = \".openshift\" // (1) } } Default: deployment as is the case with our new configuration skeleton","title":"Migrating to Tanka"},{"location":"guides/tanka_migration/#migrating-to-tanka","text":"At Cloudflight we were previously using kubecfg to deploy our applications. As of 2022-02-21 , tanka is our recommended tool for Kubernetes configurations. Reasoning for this can be found in ADR-0077. If you're still using kubecfg you're in Luck! The migration to Tanka is very simple and can be done in under five minutes. Tip TL;DR: Move stage files to environments/$NAME/main.jsonnet Create environments/$NAME/spec.json Fix Imports","title":"Migrating to Tanka"},{"location":"guides/tanka_migration/#verifying-your-current-setup","text":"Before we can start to migrate to the new setup, we should be confident in the old one to avoid issues further down the line. As a requirement, you should be able to view your configuration in the yaml format by running kubecfg show $YOUR_STAGE_FILE","title":"Verifying your current setup"},{"location":"guides/tanka_migration/#restructuring","text":"The main change required for a smooth workflow in Tanka, is a small restructuring of the directory. Our old layout prescribes a flat structure with everything in the root directory. Tanka on the other hand expects a folder per environment. To perform this step, you need to go from this: . \u251c\u2500\u2500 jsonnetfile.json \u251c\u2500\u2500 production.jsonnet \u251c\u2500\u2500 resources \u2502 \u2514\u2500\u2500 application.jsonnet \u2514\u2500\u2500 staging.jsonnet to . \u251c\u2500\u2500 jsonnetfile.json \u251c\u2500\u2500 environments \u2502 \u251c\u2500\u2500 production \u2502 \u2502 \u2514\u2500\u2500 main.jsonnet # (1) \u2502 \u2514\u2500\u2500 staging \u2502 \u2514\u2500\u2500 main.jsonnet # (2) \u2514\u2500\u2500 lib \u2514\u2500\u2500 application.libsonnet The old production.jsonnet The old staging.jsonnet","title":"Restructuring"},{"location":"guides/tanka_migration/#configuring","text":"Instead of relying on the current Kubernetes context, Tanka needs explicit information on the API Server as well as the namespace. This information is saved in the spec.json file, contained in the respective environment. The complete layout can be found in the Tanka documentation The syntax is as follows: { \"apiVersion\" : \"tanka.dev/v1alpha1\" , \"kind\" : \"Environment\" , \"metadata\" : { \"name\" : \"environments/staging\" }, \"spec\" : { \"apiServer\" : \"openshift-dev.internal.cloudflight.io:6443\" , // (1) \"namespace\" : \"762-example-staging\" , // (2) \"resourceDefaults\" : {}, \"expectVersions\" : {}, \"injectLabels\" : true } } API server URL. Excluding theh protocol, including the port Namespace of your project. Will be injected to all resources","title":"Configuring"},{"location":"guides/tanka_migration/#fixing-imports","text":"Now that you moved around the files, you will also need to fix the imports contained within them. For convenience, Tanka automatically includes the lib and vendor directory in the jsonnet path. So instead of having to write ../../lib/application.libsonnet you can simply import application.libsonnet .","title":"Fixing Imports"},{"location":"guides/tanka_migration/#verifying-the-new-configuration","text":"After fixing the imports, you can show the new configuration with the following command: tk show environments/staging","title":"Verifying the new configuration"},{"location":"guides/tanka_migration/#teamcity","text":"Tanka integration from TeamCity is supported from version 3.0.0 of the cloudflight-teamcity-dsl onwards. Example: subCloudflightProject { name = \"Deployment\" tankaApply { openShiftConfig { serviceAccountToken = \"credentialsJSON:...\" } contextDir = \".openshift\" // (1) } } Default: deployment as is the case with our new configuration skeleton","title":"TeamCity"},{"location":"library/","text":"cloudflight-libsonnet This library contains various utility modules for use with the jsonnet configuration language To get started, import the provided prelude which will composit the library for you. local k = import ( 'cloudflight-libsonnet/prelude.libsonnet' ); The prelude depends on a file called k.libsonnet being available for import. Either place it in your lib or environment folder. Using the environment folder allows for library level configuration options to be applied on an environment level. This works, because import paths are ranked as highlighted in the Tanka documentation . A pre-populated k.libsonnet is available in this library so a minimal k.libsonnet would look like this: ( import 'cloudflight-libsonnet/k.libsonnet' ) This includes k8s-libsonnet , openshift-libsonnet as well as prometheus-libsonnet For more information on customization options in k.libsonnet , take a look at the labeling extension. extensions labeling route util","title":"cloudflight-libsonnet"},{"location":"library/#cloudflight-libsonnet","text":"This library contains various utility modules for use with the jsonnet configuration language To get started, import the provided prelude which will composit the library for you. local k = import ( 'cloudflight-libsonnet/prelude.libsonnet' ); The prelude depends on a file called k.libsonnet being available for import. Either place it in your lib or environment folder. Using the environment folder allows for library level configuration options to be applied on an environment level. This works, because import paths are ranked as highlighted in the Tanka documentation . A pre-populated k.libsonnet is available in this library so a minimal k.libsonnet would look like this: ( import 'cloudflight-libsonnet/k.libsonnet' ) This includes k8s-libsonnet , openshift-libsonnet as well as prometheus-libsonnet For more information on customization options in k.libsonnet , take a look at the labeling extension. extensions labeling route util","title":"cloudflight-libsonnet"},{"location":"library/extensions/","text":"extensions Extensions available to the standard library","title":"extensions"},{"location":"library/extensions/#extensions","text":"Extensions available to the standard library","title":"extensions"},{"location":"library/labeling/","text":"labeling This extension allows you to label core kubernetes resources with useful labels. Usage To use this labeling function, edit your k.libsonnet to look something like this ( import 'cloudflight-libsonnet/k.libsonnet' ) + { _config +:: { project : 'some-project-name' } } Afterwards, all resources created (provided they use cloudflight-libsonnet/prelude.libsonnet ), will have the cloudflight.io/project=some-project-name label attached If you need to set this on a per-environment basis, move the k.libsonnet file to your environment folder as described in the Tanka documentation .","title":"labeling"},{"location":"library/labeling/#labeling","text":"This extension allows you to label core kubernetes resources with useful labels.","title":"labeling"},{"location":"library/labeling/#usage","text":"To use this labeling function, edit your k.libsonnet to look something like this ( import 'cloudflight-libsonnet/k.libsonnet' ) + { _config +:: { project : 'some-project-name' } } Afterwards, all resources created (provided they use cloudflight-libsonnet/prelude.libsonnet ), will have the cloudflight.io/project=some-project-name label attached If you need to set this on a per-environment basis, move the k.libsonnet file to your environment folder as described in the Tanka documentation .","title":"Usage"},{"location":"library/route/","text":"route Contains extensions to the default route functions provided by openshift-libsonnet Index obj v1 obj v1.route fn new(name, host, path) Fields obj v1 obj v1.route fn v1.route.new new ( name , host , path ) builds a route with a predefined host and TLS Edge termination","title":"route"},{"location":"library/route/#route","text":"Contains extensions to the default route functions provided by openshift-libsonnet","title":"route"},{"location":"library/route/#index","text":"obj v1 obj v1.route fn new(name, host, path)","title":"Index"},{"location":"library/route/#fields","text":"","title":"Fields"},{"location":"library/route/#obj-v1","text":"","title":"obj v1"},{"location":"library/route/#obj-v1route","text":"","title":"obj v1.route"},{"location":"library/route/#fn-v1routenew","text":"new ( name , host , path ) builds a route with a predefined host and TLS Edge termination","title":"fn v1.route.new"},{"location":"library/util/","text":"util The util package contains ease of use functions to simplify working with kubernetes and jsonnet Index fn routeFor(port=18080, path='/actuator/health') obj java obj java.livenessProbe fn new(port=8080) obj java.readinessProbe fn new(port=18080, path='/actuator/health') Fields fn routeFor routeFor ( port = 18080 , path = '/actuator/health' ) routeFor constructs a openshift route to the specified service. It expects a value for the hostname and defaults to '/' for the path. obj java java holds my functions related to java based applications obj java.livenessProbe fn java.livenessProbe.new new ( port = 8080 ) new constructs a fresh liveness probe, checking if the tcp port 8080 is open obj java.readinessProbe fn java.readinessProbe.new new ( port = 18080 , path = '/actuator/health' ) new constructs a fresh readiness probe, checking if the application is up. The port and path of the actuator endpoint can be changed using the parameters.","title":"util"},{"location":"library/util/#util","text":"The util package contains ease of use functions to simplify working with kubernetes and jsonnet","title":"util"},{"location":"library/util/#index","text":"fn routeFor(port=18080, path='/actuator/health') obj java obj java.livenessProbe fn new(port=8080) obj java.readinessProbe fn new(port=18080, path='/actuator/health')","title":"Index"},{"location":"library/util/#fields","text":"","title":"Fields"},{"location":"library/util/#fn-routefor","text":"routeFor ( port = 18080 , path = '/actuator/health' ) routeFor constructs a openshift route to the specified service. It expects a value for the hostname and defaults to '/' for the path.","title":"fn routeFor"},{"location":"library/util/#obj-java","text":"java holds my functions related to java based applications","title":"obj java"},{"location":"library/util/#obj-javalivenessprobe","text":"","title":"obj java.livenessProbe"},{"location":"library/util/#fn-javalivenessprobenew","text":"new ( port = 8080 ) new constructs a fresh liveness probe, checking if the tcp port 8080 is open","title":"fn java.livenessProbe.new"},{"location":"library/util/#obj-javareadinessprobe","text":"","title":"obj java.readinessProbe"},{"location":"library/util/#fn-javareadinessprobenew","text":"new ( port = 18080 , path = '/actuator/health' ) new constructs a fresh readiness probe, checking if the application is up. The port and path of the actuator endpoint can be changed using the parameters.","title":"fn java.readinessProbe.new"},{"location":"modules/","text":"What are modules? Modules are ready-to-use setups of existing applications and services. To use them, import them into your main.libsonnet like so: ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ) + { _config +: { mariadb +: { user : 'foo' , password : 'bar' , } } }","title":"What are modules?"},{"location":"modules/#what-are-modules","text":"Modules are ready-to-use setups of existing applications and services. To use them, import them into your main.libsonnet like so: ( import 'cloudflight-libsonnet/databases/mariadb.libsonnet' ) + { _config +: { mariadb +: { user : 'foo' , password : 'bar' , } } }","title":"What are modules?"},{"location":"modules/databases/mariadb/","text":"MariaDB Database Module","title":"MariaDB Database Module"},{"location":"modules/databases/mariadb/#mariadb-database-module","text":"","title":"MariaDB Database Module"}]}